<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Archive | Doyle</title>
    <description>데이터 분석의 정수리
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 02 Aug 2023 15:16:19 +0900</pubDate>
    <lastBuildDate>Wed, 02 Aug 2023 15:16:19 +0900</lastBuildDate>
    <generator>Jekyll v3.8.7</generator>
    
      <item>
        <title>희소 시간 테이블 join (프로그래머스 SQL kit)</title>
        <description>&lt;p&gt;크게 어려웠던 문제는 아니지만, 최근에 공부했던 내용을 활용해 풀이했기에 인상 깊었던 문제라 기록한다.\
영업 시간 내에 발생한 이벤트를 24시간 기준의 데이터셋으로 변형해야 하는 문제로, 요즘 postgreSQL -&amp;gt; mySQL로 번역중인 책’SQL로 시작하는 데이터분석’에서 공부한 재귀적 함수를 활용하여 희소테이블을 생성할 수 있었다.&lt;/p&gt;

&lt;h3 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ANIMAL_OUTS&lt;/code&gt; 테이블은 동물 보호소에서 입양 보낸 동물의 정보를 담은 테이블입니다. &lt;code&gt;ANIMAL_OUTS&lt;/code&gt; 테이블 구조는 다음과 같으며, &lt;code&gt;ANIMAL_ID&lt;/code&gt;, &lt;code&gt;ANIMAL_TYPE&lt;/code&gt;, &lt;code&gt;DATETIME&lt;/code&gt;, &lt;code&gt;NAME&lt;/code&gt;, &lt;code&gt;SEX_UPON_OUTCOME&lt;/code&gt;는 각각 동물의 아이디, 생물 종, 입양일, 이름, 성별 및 중성화 여부를 나타냅니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;NAME&lt;/th&gt;
      &lt;th&gt;TYPE&lt;/th&gt;
      &lt;th&gt;NULLABLE&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ANIMAL_ID&lt;/td&gt;
      &lt;td&gt;VARCHAR(N)&lt;/td&gt;
      &lt;td&gt;FALSE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ANIMAL_TYPE&lt;/td&gt;
      &lt;td&gt;VARCHAR(N)&lt;/td&gt;
      &lt;td&gt;FALSE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DATETIME&lt;/td&gt;
      &lt;td&gt;DATETIME&lt;/td&gt;
      &lt;td&gt;FALSE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NAME&lt;/td&gt;
      &lt;td&gt;VARCHAR(N)&lt;/td&gt;
      &lt;td&gt;TRUE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SEX_UPON_OUTCOME&lt;/td&gt;
      &lt;td&gt;VARCHAR(N)&lt;/td&gt;
      &lt;td&gt;FALSE&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;a-문제&quot;&gt;A. 문제&lt;/h4&gt;

&lt;p&gt;보호소에서는 몇 시에 입양이 가장 활발하게 일어나는지 알아보려 합니다. 0시부터 23시까지, 각 시간대별로 입양이 몇 건이나 발생했는지 조회하는 SQL문을 작성해주세요. 이때 결과는 시간대 순으로 정렬해야 합니다.&lt;/p&gt;

&lt;h4 id=&quot;b-예시&quot;&gt;B. 예시&lt;/h4&gt;

&lt;p&gt;SQL문을 실행하면 다음과 같이 나와야 합니다.&lt;/p&gt;

&lt;p&gt;| HOUR | COUNT |
| —- | —– |
| 0    | 0     |
| 1    | 0     |
| 2    | 0     |
| 3    | 0     |
| 4    | 0     |
| 5    | 0     |
| 6    | 0     |
| 7    | 3     |
| 8    | 1     |
| 9    | 1     |
| 10   | 2     |
| 11   | 13    |
| 12   | 10    |
| 13   | 14    |
| 14   | 9     |
| 15   | 7     |
| 16   | 10    |
| 17   | 12    |
| 18   | 16    |
| 19   | 2     |
| 20   | 0     |
| 21   | 0     |
| 22   | 0     |
| 23   | 0     |
—&lt;/p&gt;

&lt;h3 id=&quot;풀이&quot;&gt;풀이&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;재귀 함수를 통해 0-23 테이블을 생성.&lt;/li&gt;
  &lt;li&gt;이후, left join을 통해 테이블 조인&lt;/li&gt;
  &lt;li&gt;이후, null값 0으로 대체&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;WITH RECURSIVE day(hour) as (
    select 0
    union all
    select hour + 1 from day where hour &amp;lt; 23
)

select b.hour,IFNULL(a.count,0)
from day b
left join (
    select hour(datetime) as hour,count(animal_id) as count
    from ANIMAL_OUTS
    group by hour(datetime)
) a on a.hour = b.hour
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 15 Jun 2023 15:00:00 +0900</pubDate>
        <link>http://localhost:4000/articles/2023/06/15/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%A5%E1%84%89%E1%85%B3-SQL-kit-%E1%84%92%E1%85%B4%E1%84%89%E1%85%A9-%E1%84%89%E1%85%B5%E1%84%80%E1%85%A1%E1%86%AB-%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%86%AF-%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2023/06/15/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%A5%E1%84%89%E1%85%B3-SQL-kit-%E1%84%92%E1%85%B4%E1%84%89%E1%85%A9-%E1%84%89%E1%85%B5%E1%84%80%E1%85%A1%E1%86%AB-%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%86%AF-%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5</guid>
        
        <category>SQL</category>
        
        <category>MySQL</category>
        
        
        <category>SQL</category>
        
      </item>
    
      <item>
        <title>상품을 구매한 회원 비율 구하기 (프로그래머스 SQL kit)</title>
        <description>&lt;p&gt;복수의 테이블을 각각 집계하여 지표를 계산하는 문제다.
프로그래머스 SQL kit 난이도 중 가장 높은 문제(5점)이며, 재밌게 푼 기억이 있어 기록한다.&lt;/p&gt;

&lt;h3 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h3&gt;
&lt;p&gt;다음은 어느 의류 쇼핑몰에 가입한 회원 정보를 담은 &lt;code&gt;USER_INFO&lt;/code&gt; 테이블과 온라인 상품 판매 정보를 담은 &lt;code&gt;ONLINE_SALE&lt;/code&gt; 테이블 입니다. &lt;code&gt;USER_INFO&lt;/code&gt; 테이블은 아래와 같은 구조로 되어있으며 &lt;code&gt;USER_ID&lt;/code&gt;, &lt;code&gt;GENDER&lt;/code&gt;, &lt;code&gt;AGE&lt;/code&gt;, &lt;code&gt;JOINED&lt;/code&gt;는 각각 회원 ID, 성별, 나이, 가입일을 나타냅니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
      &lt;th&gt;Nullable&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;USER_ID&lt;/td&gt;
      &lt;td&gt;INTEGER&lt;/td&gt;
      &lt;td&gt;FALSE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;GENDER&lt;/td&gt;
      &lt;td&gt;TINYINT(1)&lt;/td&gt;
      &lt;td&gt;TRUE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;AGE&lt;/td&gt;
      &lt;td&gt;INTEGER&lt;/td&gt;
      &lt;td&gt;TRUE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;JOINED&lt;/td&gt;
      &lt;td&gt;DATE&lt;/td&gt;
      &lt;td&gt;FALSE&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code&gt;GENDER&lt;/code&gt; 컬럼은 비어있거나 0 또는 1의 값을 가지며 0인 경우 남자를, 1인 경우는 여자를 나타냅니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ONLINE_SALE&lt;/code&gt; 테이블은 아래와 같은 구조로 되어있으며 &lt;code&gt;ONLINE_SALE_ID&lt;/code&gt;, &lt;code&gt;USER_ID&lt;/code&gt;, &lt;code&gt;PRODUCT_ID&lt;/code&gt;, &lt;code&gt;SALES_AMOUNT&lt;/code&gt;, &lt;code&gt;SALES_DATE&lt;/code&gt;는 각각 온라인 상품 판매 ID, 회원 ID, 상품 ID, 판매량, 판매일을 나타냅니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
      &lt;th&gt;Nullable&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ONLINE_SALE_ID&lt;/td&gt;
      &lt;td&gt;INTEGER&lt;/td&gt;
      &lt;td&gt;FALSE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;USER_ID&lt;/td&gt;
      &lt;td&gt;INTEGER&lt;/td&gt;
      &lt;td&gt;FALSE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PRODUCT_ID&lt;/td&gt;
      &lt;td&gt;INTEGER&lt;/td&gt;
      &lt;td&gt;FALSE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SALES_AMOUNT&lt;/td&gt;
      &lt;td&gt;INTEGER&lt;/td&gt;
      &lt;td&gt;FALSE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SALES_DATE&lt;/td&gt;
      &lt;td&gt;DATE&lt;/td&gt;
      &lt;td&gt;FALSE&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;동일한 날짜, 회원 ID, 상품 ID 조합에 대해서는 하나의 판매 데이터만 존재합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;a-문제&quot;&gt;A. 문제&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;USER_INFO&lt;/code&gt; 테이블과 &lt;code&gt;ONLINE_SALE&lt;/code&gt; 테이블에서 2021년에 가입한 전체 회원들 중 상품을 구매한 회원수와 상품을 구매한 회원의 비율(=2021년에 가입한 회원 중 상품을 구매한 회원수 / 2021년에 가입한 전체 회원 수)을 년, 월 별로 출력하는 SQL문을 작성해주세요. 상품을 구매한 회원의 비율은 소수점 두번째자리에서 반올림하고, 전체 결과는 년을 기준으로 오름차순 정렬해주시고 년이 같다면 월을 기준으로 오름차순 정렬해주세요.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;b-예시&quot;&gt;B. 예시&lt;/h4&gt;

&lt;p&gt;예를 들어 &lt;code&gt;USER_INFO&lt;/code&gt; 테이블이 다음과 같고&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;USER_ID&lt;/th&gt;
      &lt;th&gt;GENDER&lt;/th&gt;
      &lt;th&gt;AGE&lt;/th&gt;
      &lt;th&gt;JOINED&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;26&lt;/td&gt;
      &lt;td&gt;2021-06-01&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;NULL&lt;/td&gt;
      &lt;td&gt;NULL&lt;/td&gt;
      &lt;td&gt;2021-06-25&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;NULL&lt;/td&gt;
      &lt;td&gt;2021-06-30&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;31&lt;/td&gt;
      &lt;td&gt;2021-07-03&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
      &lt;td&gt;2022-01-09&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;33&lt;/td&gt;
      &lt;td&gt;2022-02-14&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code&gt;ONLINE_SALE&lt;/code&gt; 이 다음과 같다면&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;ONLINE_SALE_ID&lt;/th&gt;
      &lt;th&gt;USER_ID&lt;/th&gt;
      &lt;th&gt;PRODUCT_ID&lt;/th&gt;
      &lt;th&gt;SALES_AMOUNT&lt;/th&gt;
      &lt;th&gt;SALES_DATE&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;54&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2022-01-01&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2022-01-25&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2022-01-30&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;253&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;2022-02-03&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;31&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2022-02-09&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;35&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2022-02-14&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;57&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2022-02-18&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;2021년에 가입한 회원은 &lt;code&gt;USER_ID&lt;/code&gt;가 1, 2, 3, 4 인 회원들로 총 4명 입니다. &lt;code&gt;ONLINE_SALE&lt;/code&gt; 테이블에서 해당 회원들에 대한 판매 데이터는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;ONLINE_SALE_ID&lt;/th&gt;
      &lt;th&gt;USER_ID&lt;/th&gt;
      &lt;th&gt;PRODUCT_ID&lt;/th&gt;
      &lt;th&gt;SALES_AMOUNT&lt;/th&gt;
      &lt;th&gt;SALES_DATE&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;54&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2022-01-01&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2022-01-25&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2022-01-30&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;31&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2022-02-09&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그러므로 년, 월 별로 상품을 구매한 회원수와 상품을 구매한 회원의 비율을 구하고 결과를 정렬하면 다음과 같아야 합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;YEAR&lt;/th&gt;
      &lt;th&gt;MONTH&lt;/th&gt;
      &lt;th&gt;PUCHASED_USERS&lt;/th&gt;
      &lt;th&gt;PUCHASED_RATIO&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;2022&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;0.5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2022&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0.3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;풀이&quot;&gt;풀이&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;아래 두 그룹을 생성하여 조인한 후, 비율을 구해야 한다.
    &lt;ul&gt;
      &lt;li&gt;고정된 2021년 가입자 총 수&lt;/li&gt;
      &lt;li&gt;2021년 가입자 중 년-월 별 구매자 수 (중복 제거 only 구매자 수)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT
	sales.year, sales.month, sales.purchased_users
	,round(sales.purchased_users / users.total, 1) AS purchased_ratio
FROM (
	SELECT year(o.sales_date) AS year, month(o.sales_date) AS month
		,count(DISTINCT o.user_id) AS purchased_users
	FROM online_sale o
	RIGHT JOIN user_info u ON u.user_id = o.user_id AND year(u.joined) = 2021
	GROUP BY date_format(sales_date, &quot;%Y-%m&quot;)) sales
JOIN (
	SELECT 2022 AS year, count(user_id) AS total
	FROM user_info
	WHERE year(joined) = 2021) users ON users.year = sales.year
ORDER BY
	year,month
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 15 Jun 2023 15:00:00 +0900</pubDate>
        <link>http://localhost:4000/articles/2023/06/15/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%A5%E1%84%89%E1%85%B3-SQL-kit-%E1%84%89%E1%85%A1%E1%86%BC%E1%84%91%E1%85%AE%E1%86%B7%E1%84%8B%E1%85%B3%E1%86%AF-%E1%84%80%E1%85%AE%E1%84%86%E1%85%A2%E1%84%92%E1%85%A1%E1%86%AB-%E1%84%92%E1%85%AC%E1%84%8B%E1%85%AF%E1%86%AB-%E1%84%87%E1%85%B5%E1%84%8B%E1%85%B2%E1%86%AF-%E1%84%80%E1%85%AE%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2023/06/15/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%A5%E1%84%89%E1%85%B3-SQL-kit-%E1%84%89%E1%85%A1%E1%86%BC%E1%84%91%E1%85%AE%E1%86%B7%E1%84%8B%E1%85%B3%E1%86%AF-%E1%84%80%E1%85%AE%E1%84%86%E1%85%A2%E1%84%92%E1%85%A1%E1%86%AB-%E1%84%92%E1%85%AC%E1%84%8B%E1%85%AF%E1%86%AB-%E1%84%87%E1%85%B5%E1%84%8B%E1%85%B2%E1%86%AF-%E1%84%80%E1%85%AE%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5</guid>
        
        <category>SQL</category>
        
        <category>MySQL</category>
        
        
        <category>SQL</category>
        
      </item>
    
      <item>
        <title>시계열 분석 - SQL로 시작하는 데이터 분석 MySQL</title>
        <description>&lt;p&gt;PostgreSQL로 작성된 서적인 OREILLY의 ‘SQL로 시작하는 데이터 분석’을 MySQL로 변환하며 스터디한 내용.&lt;/p&gt;

&lt;h2 id=&quot;시계열-분석-파트의-데이터-테이블-정리&quot;&gt;시계열 분석 파트의 데이터 테이블 정리&lt;/h2&gt;
&lt;p&gt;쿼리가 실행될 테이블 형태는 아래와 같다.&lt;/p&gt;
&lt;h3 id=&quot;a-table-scheme&quot;&gt;A. Table Scheme&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;sales_month&lt;/th&gt;
      &lt;th&gt;naics_code&lt;/th&gt;
      &lt;th&gt;kind_f_business&lt;/th&gt;
      &lt;th&gt;reason_for_null&lt;/th&gt;
      &lt;th&gt;sales&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1992-01-01&lt;/td&gt;
      &lt;td&gt;441&lt;/td&gt;
      &lt;td&gt;Motor vehicle and parts dealers&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;29811.00&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1992-01-01&lt;/td&gt;
      &lt;td&gt;4411&lt;/td&gt;
      &lt;td&gt;Automobile dealers&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;25800.00&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1992-01-01&lt;/td&gt;
      &lt;td&gt;4411, 4412&lt;/td&gt;
      &lt;td&gt;Automobile and other motor vehicle dealers&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;26788.00&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1992-01-01&lt;/td&gt;
      &lt;td&gt;44111&lt;/td&gt;
      &lt;td&gt;New car dealers&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;24056.00&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;retail_sales 테이블&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;판매 일자, 소매 업종, 판매액이 적재 되어있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;date&lt;/th&gt;
      &lt;th&gt;date_key&lt;/th&gt;
      &lt;th&gt;day_of_month&lt;/th&gt;
      &lt;th&gt;day_of_year&lt;/th&gt;
      &lt;th&gt;day_of_week&lt;/th&gt;
      &lt;th&gt;day_name&lt;/th&gt;
      &lt;th&gt;day_short_name&lt;/th&gt;
      &lt;th&gt;week_number&lt;/th&gt;
      &lt;th&gt;week_of_month&lt;/th&gt;
      &lt;th&gt;week&lt;/th&gt;
      &lt;th&gt;month_number&lt;/th&gt;
      &lt;th&gt;month_name&lt;/th&gt;
      &lt;th&gt;month+short_name&lt;/th&gt;
      &lt;th&gt;first_day_of_month&lt;/th&gt;
      &lt;th&gt;last_day_of_month&lt;/th&gt;
      &lt;th&gt;quarter_number&lt;/th&gt;
      &lt;th&gt;quarter_name&lt;/th&gt;
      &lt;th&gt;first_day_of_quarter&lt;/th&gt;
      &lt;th&gt;last_day_of_quarter&lt;/th&gt;
      &lt;th&gt;year&lt;/th&gt;
      &lt;th&gt;decade&lt;/th&gt;
      &lt;th&gt;centurays&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1770-01-01&lt;/td&gt;
      &lt;td&gt;17700101&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Monday&lt;/td&gt;
      &lt;td&gt;Mon&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1770-01-01&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;January&lt;/td&gt;
      &lt;td&gt;Jan&lt;/td&gt;
      &lt;td&gt;1770-01-01&lt;/td&gt;
      &lt;td&gt;1770-01-31&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Q1&lt;/td&gt;
      &lt;td&gt;1770-01-01&lt;/td&gt;
      &lt;td&gt;1770-03-31&lt;/td&gt;
      &lt;td&gt;1770&lt;/td&gt;
      &lt;td&gt;1770&lt;/td&gt;
      &lt;td&gt;18&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1770-01-02&lt;/td&gt;
      &lt;td&gt;17700102&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;Tuesday&lt;/td&gt;
      &lt;td&gt;Tue&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1770-01-01&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;January&lt;/td&gt;
      &lt;td&gt;Jan&lt;/td&gt;
      &lt;td&gt;1770-01-01&lt;/td&gt;
      &lt;td&gt;1770-01-31&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Q1&lt;/td&gt;
      &lt;td&gt;1770-01-01&lt;/td&gt;
      &lt;td&gt;1770-03-31&lt;/td&gt;
      &lt;td&gt;1770&lt;/td&gt;
      &lt;td&gt;1770&lt;/td&gt;
      &lt;td&gt;18&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;date_dim 테이블&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;분석에 활용하고자 하는 테이블에 특정 일자의 레코드가 삭제되어 있다면 집계 시 혼란이 발생할 수 있다.&lt;/li&gt;
  &lt;li&gt;이러한 사고를 미연에 방지하고자 날짜 룩업 테이블을 정의하고, 필요 시 join하여 결측으로 발생할 수 있는 집계 오류를 방지한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;b-날짜간-계산과-인터벌-계산을-헷갈리지-말자&quot;&gt;B. 날짜간 계산과 인터벌 계산을 헷갈리지 말자.&lt;/h3&gt;
&lt;p&gt;날짜 간 계산과 인터벌 계산 두 타입을 헷갈리지 않도록 주의하자. 날짜 간 계산은 문자 그대로 산술적인 날짜간의 차이를, 인터벌은 관념적인(하이 레벨에서의) 날짜의 개념에서의 차이를 계산한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;select date_add(date('2020-01-01'), interval 1 week)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;시계열-분석---비율과-차이&quot;&gt;시계열 분석 - 비율과 차이&lt;/h2&gt;

&lt;h3 id=&quot;a-차이-계산하기&quot;&gt;A. 차이 계산하기&lt;/h3&gt;
&lt;h4 id=&quot;a1-남여-매출-차이-subquery-ver&quot;&gt;A.1. 남여 매출 차이 Subquery ver&lt;/h4&gt;
&lt;p&gt;subquery를 활용한 계산&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT
	year(sales_month) AS years,
	a.womens_sales,
	a.mens_sales,
	a.womens_sales - a.mens_sales AS diff_sales
FROM
	retail_sales,
	(
		SELECT
			year(sales_month) AS years,
			sum(
				CASE WHEN kind_of_business = 'Women''s clothing stores' THEN
					sales
				END) AS womens_sales,
			sum(
				CASE WHEN kind_of_business = 'Men''s clothing stores' THEN
					sales
				END) AS mens_sales
		FROM
			retail_sales
		WHERE
			kind_of_business in('Women''s clothing stores', 'Men''s clothing stores')
		GROUP BY
			1) a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/GcRJNEQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;b-전체-대비-비율을-계산하기&quot;&gt;B. 전체 대비 비율을 계산하기&lt;/h3&gt;
&lt;h4 id=&quot;b1-subquery--self-join을-활용한-비율-계산&quot;&gt;B.1. subquery &amp;amp; self join을 활용한 비율 계산&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT
	sales_month,
	kind_of_business,
	sales,
	sales / aa.total_sales * 100 AS pct_total_sales
FROM (
	SELECT
		a.sales_month,
		a.kind_of_business,
		a.sales,
		sum(b.sales) AS total_sales
	FROM
		retail_sales a
		JOIN retail_sales b ON a.sales_month = b.sales_month
			AND b.kind_of_business in('Men''s clothing stores', 'Women''s clothing stores')
	WHERE
		a.kind_of_business in('Men''s clothing stores', 'Women''s clothing stores')
	GROUP BY
		1,
		2,
		3) aa
ORDER BY
	1,
	2
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;b2-partition-by-sum-윈도우함수-활용한-비율-계산&quot;&gt;B.2. Partition by, sum 윈도우함수 활용한 비율 계산&lt;/h4&gt;
&lt;p&gt;partition by 절로 함수가 계산하는 테이블의 섹션을 구분&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT
	sales_month,
	kind_of_business,
	sales,
	sum(sales) OVER (PARTITION BY sales_month) AS total_sales,
	round(sales * 100 / sum(sales) OVER (PARTITION BY sales_month), 2) AS pct
FROM
	retail_sales
WHERE
	kind_of_business in('Men''s clothing stores', 'Women''s clothing stores')
ORDER BY
	1,
	2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/hMxp250.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;c-업종별-연매출-대비-월간-매출&quot;&gt;C. 업종별, 연매출 대비 월간 매출&lt;/h3&gt;
&lt;h4 id=&quot;c1-서브쿼리-활용&quot;&gt;C.1. 서브쿼리 활용&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT
	rs.sales_month,
	rs.kind_of_business,
	SUM(rs.sales) AS sales_m,
	aa.sales_y,
	round(SUM(rs.sales) / aa.sales_y, 2) AS ratio_m_y
FROM
	retail_sales rs
	JOIN (
		SELECT
			YEAR(sales_month) AS sales_year,
			SUM(sales) AS sales_y,
			kind_of_business
		FROM
			retail_sales
		WHERE
			kind_of_business IN('Men''s clothing stores', 'Women''s clothing stores')
		GROUP BY
			sales_year,
			kind_of_business) aa ON YEAR(rs.sales_month) = aa.sales_year
	AND rs.kind_of_business = aa.kind_of_business
WHERE
	rs.kind_of_business IN('Men''s clothing stores', 'Women''s clothing stores')
GROUP BY
	rs.sales_month,
	rs.kind_of_business,
	aa.sales_y
ORDER BY
	1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;c2-윈도우-함수-활용&quot;&gt;C.2. 윈도우 함수 활용&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT
	sales_month,
	kind_of_business,
	sales,
	sum(sales) OVER (PARTITION BY year(sales_month),
		kind_of_business) AS yearly_sales,
	sales * 100 / sum(sales) OVER (PARTITION BY year(sales_month),
		kind_of_business) AS pct_yearly
FROM
	retail_sales
WHERE
	kind_of_business in('Men''s clothing stores', 'Women''s clothing stores')
ORDER BY
	1,
	2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/toTSazY.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;d-인덱싱으로-시계열-데이터-변화-이해하기&quot;&gt;D. 인덱싱으로 시계열 데이터 변화 이해하기&lt;/h3&gt;
&lt;p&gt;데이터 인덱싱은 시계열에서 베이스 구간(시작 지점)을 기준으로 데이터의 변화량을 이해하는 방법.
집계함수와 윈도우 함수를 조합하거나 self-join을 활용함. 윈도우 함수가 매우 유연한 사용성을 보이기에, 이에 익숙해지는게 좋다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT
	sales_year,
	sales,
	first_value(sales) OVER (ORDER BY sales_year) AS index_sales
FROM (
	SELECT
		year(sales_month) AS sales_year,
		sum(sales) AS sales
	FROM
		retail_sales
	WHERE
		kind_of_business in('Women''s clothing stores')
	GROUP BY
		1) a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/KhhUWJk.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;d1-윈도우-함수를-활용한-인덱싱&quot;&gt;D.1. 윈도우 함수를 활용한 인덱싱&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT
	sales_year,
	sales,
	(sales / FIRST_VALUE(sales) OVER (ORDER BY sales_year) - 1) * 100 AS index_sales
FROM (
	SELECT
		year(sales_month) AS sales_year,
		sum(sales) AS sales
	FROM
		retail_sales
	WHERE
		kind_of_business in('Women''s clothing stores')
	GROUP BY
		1) a
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;시계열-분석---시간-윈도우-롤링&quot;&gt;시계열 분석 - 시간 윈도우 롤링&lt;/h2&gt;
&lt;p&gt;집계와는 또 다른 노이즈 제거 방법. 여러 구간을 설정해 트렌드를 분석하는 시간 윈도우 롤링 (=이동 계산)
시계열 롤링 계산의 요소는 3가지. 1) 윈도우 사이즈, 2) 집계 함수, 3) 윈도우 내 데이터의 분할 혹은 그룹화
셀프조인과 윈도우 함수를 활용&lt;/p&gt;

&lt;h3 id=&quot;a-시간-윈도우-롤링-누적-합&quot;&gt;A. 시간 윈도우 롤링 누적 합&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT
	a.sales_month,
	a.sales,
	b.sales_month AS rolling_sales_month,
	b.sales AS rolling_sales
FROM
	retail_sales a
	JOIN retail_sales b ON a.kind_of_business = b.kind_of_business
		AND b.sales_month BETWEEN date_sub(a.sales_month, interval 11 MONTH)
		AND a.sales_month
		AND b.kind_of_business = 'Women''s clothing stores'
WHERE
	a.kind_of_business = 'Women''s clothing stores'
	AND a.sales_month = date('2019-12-01')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/bhW2Rzo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;b-이동평균선&quot;&gt;B. 이동평균선&lt;/h3&gt;
&lt;h4 id=&quot;b1-self-join&quot;&gt;B.1. self join&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT
	a.sales_month,
	a.sales,
	avg(b.sales) AS ma_1y,
	count(b.sales) AS records
FROM
	retail_sales a
	JOIN retail_sales b ON a.kind_of_business = b.kind_of_business
		AND b.sales_month BETWEEN date_sub(a.sales_month, interval 11 month)
		AND a.sales_month
		AND b.kind_of_business = 'Women''s clothing stores'
WHERE
	a.kind_of_business = 'Women''s clothing stores'
	AND a.sales_month &amp;gt;= '1993-01-01'
GROUP BY
	1,
	2
ORDER BY
	1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;b2-frame-문법&quot;&gt;B.2. Frame 문법&lt;/h4&gt;
&lt;p&gt;frame절은 윈도우 함수 옵션을 활용해, 각 윈도우에서 어떤 레코드를 포함할지 지정하는 문법&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;frame_end는 아래 중 하나
    &lt;ul&gt;
      &lt;li&gt;UNBOUNDED PRECEDING - 현재 행 이전의 모든 행&lt;/li&gt;
      &lt;li&gt;offset PRECEDING - 현재 행 이전의 n개 행&lt;/li&gt;
      &lt;li&gt;CURRENT ROW - 현재 행&lt;/li&gt;
      &lt;li&gt;offset FOLLOWING - 현재 행 이후의 n개 행&lt;/li&gt;
      &lt;li&gt;UNBOUNDED FOLOWING - 현재 행 이후의 모든 행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;{range | row | group} BETWEEN frame_start AND frame_end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT
	sales_month,
	avg(sales) OVER (ORDER BY sales_month ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS moving_avg,
	COUNT(sales) OVER (ORDER BY sales_month ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS records
FROM
	retail_sales
WHERE
	kind_of_business = 'Women''s clothing stores'
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;c-희소-데이터의-시간-윈도우-롤링&quot;&gt;C. 희소 데이터의 시간 윈도우 롤링&lt;/h3&gt;
&lt;p&gt;날짜 룩업 테이블 참조하여 쿼리&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT d.date,
avg(s.sales) AS moving_average,
count(s.sales) AS records,
max(
	CASE WHEN d.date = s.sales_month THEN
		s.sales
	END) AS sales_in_month
FROM
	date_dim d
	JOIN (
		SELECT
			sales_month,
			sales
		FROM
			retail_sales
		WHERE
			kind_of_business = 'Women''s clothing stores'
			AND month(sales_month)
			IN(1, 7)) s ON s.sales_month BETWEEN DATE_SUB(d.date, INTERVAL 11 MONTH)
	AND d.date
WHERE
	d.date = d.first_day_of_month
	AND d.date BETWEEN '1993-01-01'
	AND '2020-12-01'
GROUP BY
	1
ORDER BY
	1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/1o0SgBj.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;d-누적값값-계산&quot;&gt;D. 누적값값 계산&lt;/h3&gt;
&lt;h4 id=&quot;d1-ytd-윈도우-롤링&quot;&gt;D.1. YTD 윈도우 롤링&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT
	sales_month,
	sales,
	sum(sales) OVER (PARTITION BY year(sales_month)
		ORDER BY
			sales_month) AS sales_ytd
	FROM
		retail_sales
	WHERE
		kind_of_business = 'Women''s clothing stores'
	ORDER BY
		1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;d2-ytd-서브쿼리&quot;&gt;D.2. YTD 서브쿼리&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT
	a.sales_month,
	a.sales,
	sum(b.sales) AS YTD_sales
FROM
	retail_sales a
	JOIN retail_sales b ON year(a.sales_month) = year(b.sales_month)
		AND b.sales_month &amp;lt;= a.sales_month
		AND b.kind_of_business = 'Women''s clothing stores'
WHERE
	a.kind_of_business = 'Women''s clothing stores'
GROUP BY
	1,
	2
ORDER BY
	1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Ezthip4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;e-계절성-분석&quot;&gt;E. 계절성 분석&lt;/h3&gt;
&lt;p&gt;일정한 간격을 두고 규칙적으로 반복되는 패턴을 의미. 연단위, 혹은 분단위로 나타나기도 함.&lt;/p&gt;

&lt;h4 id=&quot;e1-lag-함수를-사용한-이전값-대비-비율-변화&quot;&gt;E.1. lag 함수를 사용한 이전값 대비 비율 변화&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;lag 함수는 이전행의 값을 반환한다. (lead = lag와 반대. 다음 행을 반환)&lt;/li&gt;
  &lt;li&gt;offset 옵션 : 몇 행 이전의 값을 반환할 것인가?&lt;/li&gt;
  &lt;li&gt;default 옵션 : 이전 행이 없는 경우에 반환할 값&lt;/li&gt;
  &lt;li&gt;PARTITION BY 옵션 : 생략 시, 전체 데이터셋에 대한 계산 수행&lt;/li&gt;
  &lt;li&gt;ORDER BY 옵션 : 생략 시, 현재 db 정렬 순서로 계산 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;구간단위 계산은 변화를 이해하는데 활용됨. 계절성 분석하기에는 적합하지 않음.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT
	kind_of_business,
	sales_month,
	sales,
	lag(sales) OVER (
				PARTITION BY kind_of_business ORDER BY sales_month
				) AS t,
	(sales / (lag(sales) OVER (PARTITION BY kind_of_business ORDER BY sales_month)) - 1) * 100 AS pct_growth_then_prev
FROM
	retail_sales
WHERE
	kind_of_business LIKE 'Book%'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/IXn0FVY.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;e2-구간-비교--작년-동월과의-비교&quot;&gt;E.2. 구간 비교 : 작년 동월과의 비교&lt;/h4&gt;
&lt;p&gt;전년대비 성장세를 비교.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT
	sales_month,
	sales,
	lag(sales_month) OVER (PARTITION BY month(sales_month)
		ORDER BY
			sales_month) AS prev_month,
		lag(sales) OVER (PARTITION BY month(sales_month)
			ORDER BY
				sales_month) AS prev_sales,
			100 * (sales / (lag(sales) OVER (PARTITION BY month(sales_month)
						ORDER BY
							sales_month)) - 1) AS prev_pct
			FROM
				retail_sales
			WHERE
				kind_of_business LIKE 'Book%'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/yudq1BO.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;e3-구간-비교--동월-비교-연도별-컬럼-피벗&quot;&gt;E.3. 구간 비교 : 동월 비교. 연도별 컬럼 피벗&lt;/h4&gt;
&lt;p&gt;각 연도별 시각적 비교에 용이한 피벗&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT
	month(sales_month) as month_num, 
	monthname(sales_month) as month_char,
	max(case when year(sales_month) = 1992 then sales end) as '1992 sales',
	max(case when year(sales_month) = 1993 then sales end) as '1993 sales',
	max(case when year(sales_month) = 1994 then sales end) as '1994 sales'
FROM
	retail_sales
WHERE
	kind_of_business like 'book%'
	and sales_month between date('1992-01-01') and date('1994-12-01')
group by 1,2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/wWgAwJu.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;e4-다중구간-비교-서브쿼리&quot;&gt;E.4. 다중구간 비교 서브쿼리&lt;/h4&gt;
&lt;p&gt;계산에 하나의 행이라도 null 이면 null로 처리됨을 유의.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT
	sales_month,sales,
	sales/((a.prev_sales_1 + prev_sales_2 + prev_sales_3)/3) * 100 as pct
FROM
	(
		SELECT
			sales_month,
			sales,
			lag(sales,1) over (partition by month(sales_month) 
							   order by sales_month
							  ) as prev_sales_1,
			lag(sales,2) over (partition by month(sales_month) 
							   order by sales_month
							  ) as prev_sales_2,
			lag(sales,3) over (partition by month(sales_month) 
							   order by sales_month
							  ) as prev_sales_3

		FROM
			retail_sales
		WHERE
			kind_of_business like 'Book%'
	) as a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/pnA9PKv.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;e5-다중구간-비교-프레임절&quot;&gt;E.5. 다중구간 비교 프레임절&lt;/h4&gt;
&lt;p&gt;서브쿼리와 결과는 같으나, 1개라도 null이 아니라면 계산 수행됨을 유의&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT
	sales_month,
	sales,
	sales / avg(sales) OVER (PARTITION BY month(sales_month)
		ORDER BY
			sales_month ROWS BETWEEN 3 PRECEDING AND 1 PRECEDING) AS pct_pre
	FROM
		retail_sales
	WHERE
		kind_of_business LIKE 'Book%'

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/TWZIIIl.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 01 Jun 2023 15:00:00 +0900</pubDate>
        <link>http://localhost:4000/articles/2023/06/01/%E1%84%89%E1%85%B5%E1%84%80%E1%85%A8%E1%84%8B%E1%85%A7%E1%86%AF-%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8-SQL%E1%84%85%E1%85%A9-%E1%84%89%E1%85%B5%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%92%E1%85%A1%E1%84%82%E1%85%B3%E1%86%AB-%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5-%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8-MySQL</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2023/06/01/%E1%84%89%E1%85%B5%E1%84%80%E1%85%A8%E1%84%8B%E1%85%A7%E1%86%AF-%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8-SQL%E1%84%85%E1%85%A9-%E1%84%89%E1%85%B5%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%92%E1%85%A1%E1%84%82%E1%85%B3%E1%86%AB-%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5-%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8-MySQL</guid>
        
        <category>SQL</category>
        
        
        <category>SQL</category>
        
      </item>
    
      <item>
        <title>엑셀로 풀어보는 생존 분석 로그 순위 검정</title>
        <description>&lt;h2 id=&quot;로그순위-검정-log-rank-test&quot;&gt;로그순위 검정 (Log-Rank test)&lt;/h2&gt;

&lt;h3 id=&quot;개념&quot;&gt;개념&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;두개 이상의 그룹간의 생존율의 차이가 유의미한지 알기 위한 방법이다.
두 그룹간의 총괄적인 비교를 위해 아래와 같은 가설을 설정한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$H_0 : S_1(t) = S_2(t) \text{ for all t}$&lt;/li&gt;
  &lt;li&gt;$H_1 : S_1(t) \neq S_2(t) \text{ for all t}$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이후, 관측 자료를 $t_1 &amp;lt; t_2 &amp;lt; \cdots &amp;lt; t_k$ 로 정리한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;사망&lt;/th&gt;
      &lt;th&gt;생존&lt;/th&gt;
      &lt;th&gt;계&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;그룹1&lt;/td&gt;
      &lt;td&gt;$D_{1i}$&lt;/td&gt;
      &lt;td&gt;$N_{1i}-D_{1i}$&lt;/td&gt;
      &lt;td&gt;$N_{1i}$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;그룹2&lt;/td&gt;
      &lt;td&gt;$D_{2i}$&lt;/td&gt;
      &lt;td&gt;$N_{2i}-D_{2i}$&lt;/td&gt;
      &lt;td&gt;$N_{2i}$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;계&lt;/td&gt;
      &lt;td&gt;$D_{i}$&lt;/td&gt;
      &lt;td&gt;$N_{2i}-D_{2i}$&lt;/td&gt;
      &lt;td&gt;$N_{i}$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;$t_i$에서 $N_{1i},N_{2i},D_{i}$ 가 고정되어 있다면, $D_{1i}$가 초기하분포를 따르며, 그 평균과 분산은 아래와 같다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E(D_{1i}) = N_{1i}D_{i}/N{i} = E_{1i}&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;V(D_{1i}) = V_{1i}&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;초기하 분포를 따른다면 각 테이블마다 평균과 분산을 구하고, 이를 활용하여 카이 제곱 검정 통계량을 구할 수 있다. 이 경우, 검정통계량 T는 자유도 1인 카이제곱분포를 따른다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;T = \dfrac{(\sum_{i=1}^{k} D_{1i}-E_{1i})^2}{\sum_{i=1}^{k} V_{1i}}&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;만약 T의 값이 임계치보다 크다면 두 그룹의 생존함수가 같다는 귀무가설을 기각하고 유의미한 차이가 있다고 볼 수 있다. 또한, 각 시점에서의 가중치를 주어 아래와 같은 검정통계량 식을 도출할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;T = \dfrac{(\sum_{i=1}^{k} w_{i}D_{1i}-E_{1i})^2}{\sum_{i=1}^{k} w_{i}^{2}V_{1i}}&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;로그 랭크 테스트와 윌콕슨 검정 모두 생존곡선이 crossover될 경우, 그 차이를 테스트할 수 없다.
로그랭크 테스트는 두 그룹에서 한 그룹의 생존확률이 비례적인 증감을 테스트하는데 적합하다. (proportional hazards model)
윌콕슨 테스트는 사건시간이 log-normal distribution(두 그룹간에 분산이 동일하고 평균은 다를 때) 적합하다.&lt;/p&gt;

&lt;h3 id=&quot;예시&quot;&gt;예시&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;각기 다른 치료법을 적용한 Trial A 그룹과 Trial B 그룹이 아래와 같이 존재한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;각 컬럼 1은 Duration Time으로 t이다.&lt;/li&gt;
  &lt;li&gt;각 컬럼 2는 사망이 발생했거나 (1), 절단(0)을 나타낸다.
&lt;img src=&quot;https://i.imgur.com/eSbdZ1G.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 자료를 아래와 같이 정리한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;t : duration time&lt;/li&gt;
  &lt;li&gt;d : 사망 발생&lt;/li&gt;
  &lt;li&gt;n : 관측 수&lt;/li&gt;
  &lt;li&gt;S(t) : 생존 함수 ($1-\frac{d}{n}$의 누적 곱)
&lt;img src=&quot;https://i.imgur.com/PH7yb8x.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;생존 곡선은 아래와 같이 그려진다. 시각적으로 볼때 두 그룹간 큰 차이가 없을것으로 예상된다. 보다 더 정밀한 비교를 위해 로그 순위 검정을 실시한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/6joIQbd.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;로그 순위 검정은 앞서 말했듯, 카이 제곱 검정과 유사하다. 로그 순위를 계산하기 위해 각 t별 d의 기댓값을 계산하여 자료를 생성한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기댓값
    &lt;ul&gt;
      &lt;li&gt;$e_{j}^{A} = n_{j}^{A} \cdot \dfrac{d_j}{n_j}$&lt;/li&gt;
      &lt;li&gt;$e_{j}^{B} = n_{j}^{B} \cdot \dfrac{d_j}{n_j}$
        &lt;ul&gt;
          &lt;li&gt;$d_j = d_j^A+d_j^B, n_j = n_j^A+n_j^B$&lt;/li&gt;
          &lt;li&gt;$e_j^A + e_j^B = d_j^A + d_j^B$&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;LogRank = \dfrac{(Obs_{A} - Exp_{A})^2}{Exp_A} + \dfrac{(Obs_{B} - Exp_{B})^2}{Exp_B}&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;=\dfrac{(12-9.82)^2}{9.82} + \dfrac{(8-10.17)^2}{10.17}&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/xFaXp0m.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;$H0$이 참이라면, 로그랭크테스트는 자유도가 1인 카이제곱분포를 따른다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;LR \sim \chi^2(1)&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 두 그룹의 로그랭크통계값은 0.94이고, 이 P-value는 0.33으로 0.05 유의수준보다 크다.
따라서 해당 그룹의 생존율에는 큰 차이가 없다.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://real-statistics.com/survival-analysis/kaplan-meier-procedure/log-rank-test/&quot;&gt;Log-Rank Test | Real Statistics Using Excel&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://boogling.tistory.com/entry/%EC%83%9D%EC%A1%B4%EB%B6%84%EC%84%9D-Survival-Function%EC%9D%98-%EC%B0%A8%EC%9D%B4-Log-Rank-Test&quot;&gt;생존분석 - Survival Function의 차이 Log-Rank Test&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;amp;blogId=euleekwon&amp;amp;logNo=221441257643&quot;&gt;[통계 공부] Log-rank test(로그 순위법) : 네이버 블로그&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 29 Mar 2023 15:00:00 +0900</pubDate>
        <link>http://localhost:4000/articles/2023/03/29/%EC%83%9D%EC%A1%B4-%EB%B6%84%EC%84%9D-%EB%A1%9C%EA%B7%B8-%EC%88%9C%EC%9C%84-%EA%B2%80%EC%A0%95</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2023/03/29/%EC%83%9D%EC%A1%B4-%EB%B6%84%EC%84%9D-%EB%A1%9C%EA%B7%B8-%EC%88%9C%EC%9C%84-%EA%B2%80%EC%A0%95</guid>
        
        <category>머신러닝</category>
        
        <category>생존분석</category>
        
        
        <category>머신러닝</category>
        
      </item>
    
      <item>
        <title>생존 분석 - 카플란 마이어 추정 [파이썬 예제]</title>
        <description>&lt;h2 id=&quot;카플란-마이어-하드코딩&quot;&gt;카플란 마이어 하드코딩&lt;/h2&gt;

&lt;p&gt;이번 예제에서는 강아지 보호소를 예시로 사용한다. 강아지 보호소에는 새로운 강아지가 입소하고, 입양되어 퇴소하는 사건이 발생한다. 따라서 강아지가 보호소에 남아있는 기간을 생존기간으로, 입양되어 퇴소하는 사건을 위험으로 간주한다.&lt;/p&gt;

&lt;h3 id=&quot;데이터-셋-구성&quot;&gt;데이터 셋 구성&lt;/h3&gt;
&lt;p&gt;가상의 강아지 보호소 데이터 구성은 아래와 같다.&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;start : 보호소 입소 시간&lt;/li&gt;
  &lt;li&gt;end : 입양 사건 발생 시간. 9는 관측 종료 시점이므로 해당 컬럼이 9일 경우 cencored&lt;/li&gt;
  &lt;li&gt;status : 1일 경우 사건 발생, 0일 경우 사건 미발생&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

obs = pd.DataFrame()

obs['start'] = 0,1,2,2,4,6,7
obs['end'] = 5,2,6,9,9,8,9
obs['status'] = 1,1,1,0,0,1,0
obs
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;style scoped=&quot;&quot;&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
&lt;/style&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;
  &lt;thead&gt;
    &lt;tr style=&quot;text-align: right;&quot;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;start&lt;/th&gt;
      &lt;th&gt;end&lt;/th&gt;
      &lt;th&gt;status&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6&lt;/th&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;h4 id=&quot;a-레코드-plot&quot;&gt;A. 레코드 plot&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def plot_lifelines(obs):
    for y,row in obs.iterrows():
        start = row['start']
        end = row['end']
        status = row['status']

        if status == 0:
            plt.hlines(y,start,end,color='C0')
        else :
            plt.hlines(y,start,end,color='C1')
            plt.plot(end,y,marker='o',color='C1')
    plt.xlabel('Time (weeks)')
    plt.ylabel('Dog Index')
    plt.gca().invert_yaxis()

plot_lifelines(obs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/s29QseL.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;카플란-마이어-추정&quot;&gt;카플란 마이어 추정&lt;/h3&gt;
&lt;p&gt;카플란 마이어 추정은 두가지 아이디어에서 시작한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;레코드의 시작지점을 무시하고 duration time만을 고려한다.&lt;/li&gt;
  &lt;li&gt;위험함수를 추정한다. 위험함수는 각 기간 내 발생한 사건을 위험에 처한 총 레코드 수로 나누어 도출한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;a-duration-time-을-기준으로-데이터세트-생성&quot;&gt;A. Duration time 을 기준으로 데이터세트 생성&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;duration = obs['end'] - obs['start']
shifted = obs.copy()
shifted['start'] = 0
shifted['end'] = duration

plot_lifelines(shifted)
plt.xlabel('Duration (week)');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/AoD4nlb.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;b-위험함수-도출을-위한-at-risk-도출&quot;&gt;B. 위험함수 도출을 위한 At Risk 도출&lt;/h4&gt;
&lt;p&gt;At Risk는 특정 기간동안 사건이 발생하지 않았거나 절단되지 않은 레코드의 수를 뜻한다.
아래 코드는 numpy의 meshgrid 함수를 이용하여 사건이 발생한 Duration Time과 각 레코드의 end 시점을 각각 비교한다. 
사건이 발생한 $Duration Time_i$ 보다 레코드의 $end_i$ 시점이 같거나 크다면, $DurationTime_i$ 내에 생존한 레코드이다. 즉, 사건이 발생한 각각의 Duration Time 내 위험에 노출된 레코드들의 수를 계산한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;ts = duration.unique()
ts.sort()
ts
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;⇒ array([1, 2, 4, 5, 7])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;E,T = np.meshgrid(shifted['end'],ts)
E
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;array([[5, 1, 4, 7, 5, 2, 2],
       [5, 1, 4, 7, 5, 2, 2],
       [5, 1, 4, 7, 5, 2, 2],
       [5, 1, 4, 7, 5, 2, 2],
       [5, 1, 4, 7, 5, 2, 2]])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;at_risk = (T &amp;lt;= E).sum(axis=1)
at_risk
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;array([7, 6, 4, 3, 1])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;T&amp;lt;br
[&amp;lt;br&amp;gt;
    [1, 1, 1, 1, 1, 1, 1],&amp;lt;br&amp;gt;
    [2, 2, 2, 2, 2, 2, 2],&amp;lt;br&amp;gt;
    [4, 4, 4, 4, 4, 4, 4],&amp;lt;br&amp;gt;
    [5, 5, 5, 5, 5, 5, 5],&amp;lt;br&amp;gt;
    [7, 7, 7, 7, 7, 7, 7]&amp;lt;br&amp;gt;
]&amp;lt;br&amp;gt;
&amp;lt;=
E&amp;lt;br&amp;gt;
[&amp;lt;br&amp;gt;
    [5, 1, 4, 7, 5, 2, 2],&amp;lt;br&amp;gt;
    [5, 1, 4, 7, 5, 2, 2],&amp;lt;br&amp;gt;
    [5, 1, 4, 7, 5, 2, 2],&amp;lt;br&amp;gt;
    [5, 1, 4, 7, 5, 2, 2],&amp;lt;br&amp;gt;
    [5, 1, 4, 7, 5, 2, 2]&amp;lt;br&amp;gt;
]&amp;lt;br&amp;gt;

This results in a boolean array:

[&amp;lt;br&amp;gt;
    [True,  True,  True,  True,  True,  True,  True],&amp;lt;br&amp;gt;
    [True, False,  True, True,  True, True, True],&amp;lt;br&amp;gt;
    [True, False,  True, True,  True, False, False],&amp;lt;br&amp;gt;
    [True, False,  False, True,  True, False, False],&amp;lt;br&amp;gt;
    [False, False, False, True, False, False, False]&amp;lt;br&amp;gt;
]&amp;lt;br&amp;gt;

[7, 6, 4, 3, 1]

This gives us the number of individuals who are considered &quot;at risk&quot; for each time point.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;c-위험함수-도출을-위한-사건-발생-수-도출&quot;&gt;C. 위험함수 도출을 위한 사건 발생 수 도출&lt;/h4&gt;
&lt;p&gt;각 t(Duration Time)마다 입양이 발생한 수를 계산한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;adopted = pd.Series(0,index=ts)

for t in ts:
    k = (shifted['status']==1) &amp;amp; (t == shifted['end'])
    adopted[t] = k.sum()

adopted
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1    1
2    1
4    1
5    1
7    0
dtype: int64
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;d = dict(adopted=adopted,
        at_risk=at_risk)
df= pd.DataFrame(d,index=ts)
df
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;style scoped=&quot;&quot;&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
&lt;/style&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;
  &lt;thead&gt;
    &lt;tr style=&quot;text-align: right;&quot;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;adopted&lt;/th&gt;
      &lt;th&gt;at_risk&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;h4 id=&quot;d-위험함수-계산-사건발생-수--위험에-노출된-레코드-수&quot;&gt;D. 위험함수 계산. 사건발생 수 / 위험에 노출된 레코드 수&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;df['hazard'] = df['adopted']/df['at_risk']
df
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;style scoped=&quot;&quot;&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
&lt;/style&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;
  &lt;thead&gt;
    &lt;tr style=&quot;text-align: right;&quot;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;adopted&lt;/th&gt;
      &lt;th&gt;at_risk&lt;/th&gt;
      &lt;th&gt;hazard&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;0.142857&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;0.166667&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0.250000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0.333333&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;h3 id=&quot;생존함수-계산&quot;&gt;생존함수 계산&lt;/h3&gt;
&lt;p&gt;위에서 계산한 위험함수는 특정 기간에 사건이 발생할 확률이다. 이 케이스에서 사건은 입양이다.
따라서 반대의 케이스는 입양이 되지 않은 생존이며, 이 생존의 누적곱이 생존함수가 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;df['surv'] = (1 - df['hazard']).cumprod()
df
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;style scoped=&quot;&quot;&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
&lt;/style&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;
  &lt;thead&gt;
    &lt;tr style=&quot;text-align: right;&quot;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;adopted&lt;/th&gt;
      &lt;th&gt;at_risk&lt;/th&gt;
      &lt;th&gt;hazard&lt;/th&gt;
      &lt;th&gt;surv&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;0.142857&lt;/td&gt;
      &lt;td&gt;0.857143&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;0.166667&lt;/td&gt;
      &lt;td&gt;0.714286&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0.250000&lt;/td&gt;
      &lt;td&gt;0.535714&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0.333333&lt;/td&gt;
      &lt;td&gt;0.357143&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
      &lt;td&gt;0.357143&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;누적 분포함수는 1 - 생존함수이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;df['cdf'] = 1 - df['surv']
df
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;style scoped=&quot;&quot;&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
&lt;/style&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;
  &lt;thead&gt;
    &lt;tr style=&quot;text-align: right;&quot;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;adopted&lt;/th&gt;
      &lt;th&gt;at_risk&lt;/th&gt;
      &lt;th&gt;hazard&lt;/th&gt;
      &lt;th&gt;surv&lt;/th&gt;
      &lt;th&gt;cdf&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;0.142857&lt;/td&gt;
      &lt;td&gt;0.857143&lt;/td&gt;
      &lt;td&gt;0.142857&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;0.166667&lt;/td&gt;
      &lt;td&gt;0.714286&lt;/td&gt;
      &lt;td&gt;0.285714&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0.250000&lt;/td&gt;
      &lt;td&gt;0.535714&lt;/td&gt;
      &lt;td&gt;0.464286&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0.333333&lt;/td&gt;
      &lt;td&gt;0.357143&lt;/td&gt;
      &lt;td&gt;0.642857&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
      &lt;td&gt;0.357143&lt;/td&gt;
      &lt;td&gt;0.642857&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;확률 질량함수는 cdf의 변화량이다&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;df['pdf'] = np.diff(df['cdf'],prepend=0)
df
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;style scoped=&quot;&quot;&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
&lt;/style&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;
  &lt;thead&gt;
    &lt;tr style=&quot;text-align: right;&quot;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;adopted&lt;/th&gt;
      &lt;th&gt;at_risk&lt;/th&gt;
      &lt;th&gt;hazard&lt;/th&gt;
      &lt;th&gt;surv&lt;/th&gt;
      &lt;th&gt;cdf&lt;/th&gt;
      &lt;th&gt;pdf&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;0.142857&lt;/td&gt;
      &lt;td&gt;0.857143&lt;/td&gt;
      &lt;td&gt;0.142857&lt;/td&gt;
      &lt;td&gt;0.142857&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;0.166667&lt;/td&gt;
      &lt;td&gt;0.714286&lt;/td&gt;
      &lt;td&gt;0.285714&lt;/td&gt;
      &lt;td&gt;0.142857&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0.250000&lt;/td&gt;
      &lt;td&gt;0.535714&lt;/td&gt;
      &lt;td&gt;0.464286&lt;/td&gt;
      &lt;td&gt;0.178571&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0.333333&lt;/td&gt;
      &lt;td&gt;0.357143&lt;/td&gt;
      &lt;td&gt;0.642857&lt;/td&gt;
      &lt;td&gt;0.178571&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
      &lt;td&gt;0.357143&lt;/td&gt;
      &lt;td&gt;0.642857&lt;/td&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;h2 id=&quot;라이브러리를-이용한-카플란마이어-추정&quot;&gt;라이브러리를 이용한 카플란마이어 추정&lt;/h2&gt;
&lt;p&gt;위의 하드코딩으로 구현한 카플란 마이어 추정은 lifelines 라이브러리를 활용하면 간단히 구현할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;from lifelines import KaplanMeierFitter
kmf = KaplanMeierFitter()

T = shifted['end']
E = shifted['status']

kmf.fit(T,E)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;lifelines.KaplanMeierFitter:&quot;KM_estimate&quot;, fitted with 7 total observations, 3 right-censored observations&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;kmf.survival_function_
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;style scoped=&quot;&quot;&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
&lt;/style&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;
  &lt;thead&gt;
    &lt;tr style=&quot;text-align: right;&quot;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;KM_estimate&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;timeline&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0.0&lt;/th&gt;
      &lt;td&gt;1.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1.0&lt;/th&gt;
      &lt;td&gt;0.857143&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2.0&lt;/th&gt;
      &lt;td&gt;0.714286&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4.0&lt;/th&gt;
      &lt;td&gt;0.535714&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5.0&lt;/th&gt;
      &lt;td&gt;0.357143&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7.0&lt;/th&gt;
      &lt;td&gt;0.357143&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;생존함수의 confidence interval을 구할 수 있다. 현재 예제의 자료가 매우 작기에 CI는 상당히 넓다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;ci = kmf.confidence_interval_survival_function_
ci
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;style scoped=&quot;&quot;&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
&lt;/style&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;
  &lt;thead&gt;
    &lt;tr style=&quot;text-align: right;&quot;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;KM_estimate_lower_0.95&lt;/th&gt;
      &lt;th&gt;KM_estimate_upper_0.95&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0.0&lt;/th&gt;
      &lt;td&gt;1.000000&lt;/td&gt;
      &lt;td&gt;1.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1.0&lt;/th&gt;
      &lt;td&gt;0.334054&lt;/td&gt;
      &lt;td&gt;0.978561&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2.0&lt;/th&gt;
      &lt;td&gt;0.258154&lt;/td&gt;
      &lt;td&gt;0.919797&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4.0&lt;/th&gt;
      &lt;td&gt;0.131988&lt;/td&gt;
      &lt;td&gt;0.824997&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5.0&lt;/th&gt;
      &lt;td&gt;0.051977&lt;/td&gt;
      &lt;td&gt;0.698713&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7.0&lt;/th&gt;
      &lt;td&gt;0.051977&lt;/td&gt;
      &lt;td&gt;0.698713&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;ts = ci.index
low, high = np.transpose(ci.values)
plt.fill_between(ts,low,high,color='grey',alpha=0.3)
kmf.survival_function_.plot(ax=plt.gca())
plt.ylabel('Survival function')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Twq7kCX.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;kmf.median_survival_time_
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.0&lt;/p&gt;

&lt;h3 id=&quot;카플란-마이어-곡선-해석&quot;&gt;카플란 마이어 곡선 해석&lt;/h3&gt;
&lt;p&gt;생존 곡선을 통해 다양한 의사결정을 내릴 수 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;해당 강아지 보호소의 중위 생존값은 5. 따라서 입소 후 5주째 50%의 입양이 발생한다.&lt;/li&gt;
  &lt;li&gt;공간 활용 최적화를 위해 어느 주기로 신규 입소견을 받아야 할지 결정할 수 있다.&lt;/li&gt;
  &lt;li&gt;또한, 입양 사건 발생시 매출이 발생한다면, 생존기간과 매출을 곱하여 LTV와 예상 매출을 계산할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Wed, 29 Mar 2023 15:00:00 +0900</pubDate>
        <link>http://localhost:4000/articles/2023/03/29/%E1%84%89%E1%85%A2%E1%86%BC%E1%84%8C%E1%85%A9%E1%86%AB%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8-%E1%84%8F%E1%85%A1%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%86%AB-%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5-%E1%84%8B%E1%85%A8%E1%84%8C%E1%85%A6</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2023/03/29/%E1%84%89%E1%85%A2%E1%86%BC%E1%84%8C%E1%85%A9%E1%86%AB%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8-%E1%84%8F%E1%85%A1%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%86%AB-%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5-%E1%84%8B%E1%85%A8%E1%84%8C%E1%85%A6</guid>
        
        <category>머신러닝</category>
        
        <category>생존분석</category>
        
        
        <category>머신러닝</category>
        
      </item>
    
      <item>
        <title>생존 분석 - 카플란 마이어 추정</title>
        <description>&lt;h2 id=&quot;생존분석이란&quot;&gt;생존분석이란&lt;/h2&gt;
&lt;p&gt;생존분석은 자료가 절단되는 Cencoring을 고려하며 Time to Event에 대해 분석하기 위한 분석 방법이다.
이는 Linear Regression, t-test, Logistic Regression등의 통계 방법으로는 해결할 수 없다.
생존분석의 목적은 아래와 같다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;User의 Time to Event를 예측한다.&lt;/li&gt;
  &lt;li&gt;둘 이상의 그룹간의 Time to Event를 비교한다.&lt;/li&gt;
  &lt;li&gt;변수들이 Event에 미치는 영향을 파악하고 비교한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;특정 사건이 발생하는데 까지 걸리는 시간을 다루는 분석 방법인 생존분석은 특정 사건(Event)이 ‘죽음’이나 ‘발병’이 될 수 있으며, 시간(Time)은 그 이벤트가 발생하기까지 걸린 시간을 의미한다.
‘죽음’ 이라는 사건은 통칭 실패라고 불리며, 시간은 생존시간이라 한다.
유저관점에서 접근한다면, 이탈을 실패로 정의하고, 이탈 하기까지의 시간을 생존시간으로 정의할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/mEgdSVy.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;y축이 유저, x축이 생존 시간이다. 관측기간 동안 이탈이 발생했다면 검정색 점, 관측기간 이내로 파악이 안된 자료는 중도절단 자료(Cencored)라고 부른다. 생존시간이 얼마인지 정확히 모르기 떄문에, 흰색 점으로 표시하고 기간에 +표시를 표기한다.
중도 절단된 생존시간은 불완전한 관측값이지만, 이를 무시하지 않는다. 단, 이탈이 완전하게 관찰된 유저와는 구분을 두어 확률계산에 반영한다.&lt;/p&gt;

&lt;h3 id=&quot;생존-함수와-위험-함수&quot;&gt;생존 함수와 위험 함수&lt;/h3&gt;
&lt;h4 id=&quot;a-생존함수-survival-function&quot;&gt;A. 생존함수 (Survival Function)&lt;/h4&gt;
&lt;p&gt;특정 시기보다 더 오래 생존할 확률을 추정한다. 생존 함수는 아래와 같다.
&lt;script type=&quot;math/tex&quot;&gt;S(t) = P(T &gt; t)&lt;/script&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$T$ : 유저 생존 기간 T. 확률변수 (random variable)&lt;/li&gt;
  &lt;li&gt;$t : T$의 특정 값&lt;/li&gt;
  &lt;li&gt;$F(t)$ : 특점 시점 t까지 event가 발생했을 확률. f(t)의 누적밀도함수이며 $1-S(t)$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;생존 함수를 그림으로 표현한 것은 생존 곡선이다. 생존시간 t가 증가하며 생존확률 $S(t)$는 점점 감소한다. 이론적으로 생존 시간의 범위는 0부터 무한대이다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$S(0) = 1$&lt;/li&gt;
  &lt;li&gt;$S(\infty) = 0$ 
&lt;img src=&quot;https://i.imgur.com/i0euGqY.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;b-위험-함수-hazard-function&quot;&gt;B. 위험 함수 (Hazard Function)&lt;/h4&gt;
&lt;p&gt;$h(t)$ : $t$까지 생존했을때, 직후 event가 일어날 조건부 확률. 특정 시기에 사건이 발생할 확률을 추정한다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
h(t) = \lim_{\Delta t \to 0} P(t \leq T &lt; t + \Delta|T &gt; t) %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;= \dfrac{f(t)}{S(t)}&lt;/script&gt;

&lt;h3 id=&quot;생존-함수-추정&quot;&gt;생존 함수 추정&lt;/h3&gt;
&lt;h4 id=&quot;a-카플란-마이어-추정량&quot;&gt;A. 카플란 마이어 추정량&lt;/h4&gt;
&lt;p&gt;Kaplan-Meier estimation을 통해 집단간의 시간에 따른 생존율을 쉽게 비교할 수 있다. 적은 표본에 대해서도 적용할 수 있어 널리 사용된다.
요약에는 Median Survivor 값을 사용하며, 기간별 구간 생존비율을 사용할 수 도 있다.&lt;/p&gt;

&lt;p&gt;카플란 추정치의 수식은 아래와 같다. 각 구간별 생존자수의 비율로 구간생존율 $P(t)$를 산출하고, 누적생존율 $S(t)$는 구간생존율 $P(t)$를 차례로 곱하여 산출한다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;S(t_i) = P(T&gt;t_i) = P(T&gt;T_1)P(T&gt;t_2|T&gt;t_1) \cdots P(T&gt;t_i|T&gt;t_i-1)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;=\prod_{{t_i} \leq t} \left( 1-\dfrac{d_i}{n_i} \right),\delta_i = 0(cencoring)\ or \ 1,d_i=\text{사망자수}&lt;/script&gt;

&lt;p&gt;따라서 카플란 마이어 추정에 의한 생존함수는 어떤 사람이 $t_1$ 시점까지 생존했을 확률과, $t_1$ 시점까지 생존했다면 $t_n$ 시점까지 살아있을 확률들의 곱해진 확률이다. $S(t) = 0.5$ 되는 $t$는 중간 생존 기간이라 한다.&lt;/p&gt;

&lt;h5 id=&quot;a1-카플란-마이어-추정-예제-1&quot;&gt;A.1. 카플란 마이어 추정 예제 1.)&lt;/h5&gt;
&lt;p&gt;샘플 5명, 관측기간 중 4명이 사망하고 1명이 cencored된 예제이다. 코드 없이 시나리오를 통해 이해해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/16DSEOu.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;생존곡선 작도
    &lt;ul&gt;
      &lt;li&gt;0개월째, 5/5 전원 생존&lt;/li&gt;
      &lt;li&gt;5개월째, 4명 중 1명 사망하여 4/5 즉, 생존확률 80%&lt;/li&gt;
      &lt;li&gt;20개월째, 4명 중 1명 기록 절단으로 인원 3명으로 축소&lt;/li&gt;
      &lt;li&gt;30개월째, 3명 중 1명 사망하여 인원 2명으로 축소.
        &lt;ul&gt;
          &lt;li&gt;이전 생존확률 80%에 절단기록 반영한 2/3 곱하여 생존확률 53%&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;50개월째, 1명 사망하여 인원 1명으로 축소.
        &lt;ul&gt;
          &lt;li&gt;이전 생존확률 53% 에 1/2 곱하여 26.5%&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;60개월째, 1명 사망하여 전원 사망&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자료 요약 : Survivor Fraction이 50%가 되는 지점이 Median Survival Time
    &lt;ul&gt;
      &lt;li&gt;50개월째.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자료 요약 2 : 시점별 생존율을 계산하여 자료요약에 활용할 수 도 있다.
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://i.imgur.com/eHcSvtW.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;a2-카플란-마이어-추정-예제-2&quot;&gt;A.2. 카플란 마이어 추정 예제 2.)&lt;/h5&gt;
&lt;p&gt;강아지 보호소를 예시로 사용한다. 강아지 보호소에는 새로운 강아지가 입소하고, 입양되어 퇴소하는 사건이 발생한다. 따라서 강아지가 보호소에 남아있는 기간을 생존기간으로, 입양되어 퇴소하는 사건을 위험으로 간주한다.
[[생존분석 KM 예제]]&lt;/p&gt;

&lt;h3 id=&quot;활용안&quot;&gt;활용안&lt;/h3&gt;
&lt;h4 id=&quot;a-변수-변경&quot;&gt;A. 변수 변경&lt;/h4&gt;
&lt;p&gt;$S(T) = P(T&amp;gt;t)$에서 $T$는 관찰 시간이다. 만약 이를 다른 변수로 바꾼다면 새로운 분석이 된다. 게임 레벨 등, 시간이 흐르며 변화하는 진행 척도는 무엇이든 대입할 수 있다. 그룹도 다양하게 설정하여 코호트 분석에 깊이를 더할 수 있다.
혹은, 이탈이 아닌 구매 등의 긍정적인 지표로 변경하여 생존분석을 진행할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;b-설명-변수-추가&quot;&gt;B. 설명 변수 추가&lt;/h4&gt;
&lt;p&gt;어떤 변수가 수명에 영향을 주는지 분석할 수 있다. 두 그룹간에 차이가 있다면, 어떤 피쳐가 생존기간에 영향을 미치는지 파악할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;c-위험-추정&quot;&gt;C. 위험 추정&lt;/h4&gt;
&lt;p&gt;생존 곡선을 그린다면, 각 시각에서의 위험률을 계산할 수 있다. 위험함수를 도출하면, 유저들이 어느 시점에서 가장 이탈할 가능성이 높은지 failure rate 관점에서 살펴볼 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;d-ltv-돈과-시간-측정&quot;&gt;D. LTV 돈과 시간 측정&lt;/h4&gt;
&lt;p&gt;단위시간당 가치를 유저의 생존곡선과 결합해야 유저의 총 가치가 어느정도인지 알 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;refernce&quot;&gt;Refernce&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=e50uqS45sZE&amp;amp;ab_channel=%ED%86%B5%EA%B3%84%EB%8A%94%EC%97%90%EC%9D%B4%EC%8A%A4&quot;&gt;(44) [최지민 박사의 통계 TV] 카플란-마이어 추정 - YouTube&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://3months.tistory.com/349&quot;&gt;생존분석 - 생존분석의 목적과 생존함수, 위험함수의 정의 :: Deep Play&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://bioinformaticsandme.tistory.com/223&quot;&gt;생존 분석 (Survival analysis) :: BioinformaticsAndMe&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://sticky-ai.github.io/survival%20analysis/2020/07/29/survival_analysis_kaplan_meier/&quot;&gt;STIKY AI&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://allendowney.github.io/SurvivalAnalysisPython/02_kaplan_meier.html&quot;&gt;Kaplan-Meier Estimation — Survival Analysis in Python&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://boxnwhis.kr/2015/03/15/drawing_survival_curves_of_users.html&quot;&gt;BOX AND WHISKER&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 27 Mar 2023 15:00:00 +0900</pubDate>
        <link>http://localhost:4000/articles/2023/03/27/%EC%83%9D%EC%A1%B4-%EB%B6%84%EC%84%9D-%EC%B9%B4%ED%94%8C%EB%9E%80-%EB%A7%88%EC%9D%B4%EC%96%B4-%EC%B6%94%EC%A0%95</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2023/03/27/%EC%83%9D%EC%A1%B4-%EB%B6%84%EC%84%9D-%EC%B9%B4%ED%94%8C%EB%9E%80-%EB%A7%88%EC%9D%B4%EC%96%B4-%EC%B6%94%EC%A0%95</guid>
        
        <category>머신러닝</category>
        
        <category>생존분석</category>
        
        
        <category>머신러닝</category>
        
      </item>
    
      <item>
        <title>이디야는 스타벅스 주변에 매장을 낸다? 진실 혹은 거짓 (태블로 시각화)</title>
        <description>&lt;h3 id=&quot;스타벅스-옆에는-항상-이디야가-있다&quot;&gt;스타벅스 옆에는 항상 이디야가 있다?&lt;/h3&gt;
&lt;p&gt;이디야는 스타벅스 근처에 매장을 내며 낙수효과를 노리는 전략을 운용한다고 한다.
이디야측은 부정하지만, 데이터로 검증된 사례이다.
그럼 스타벅스 주변에 어떤식으로 이디야가 포진해있을까? 이를 확인하기 위해 태블로를 활용하여 시각화 자료를 제작해보자.&lt;/p&gt;

&lt;h3 id=&quot;목표-대시보드&quot;&gt;목표 대시보드&lt;/h3&gt;
&lt;iframe src=&quot;https://giphy.com/embed/zGPK1cnzPN8pTKdph7&quot; width=&quot;480&quot; height=&quot;270&quot; frameborder=&quot;0&quot; class=&quot;giphy-embed&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href=&quot;https://giphy.com/gifs/zGPK1cnzPN8pTKdph7&quot;&gt;via GIPHY&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;구성&quot;&gt;구성&lt;/h3&gt;
&lt;p&gt;데이터셋은 아래와 같이, 스타벅스와 이디야의 정보가 횡으로 나열되어 있다. 
각 브랜드의 총 레코드 수는 동일하나, 구별 매장 수는 상이하다.
두 종류의 거리를 계산하기 위해서는 위경도를 포함한 데이터셋이 아래와 같이 횡으로 나열되어 있는 쉐입이 용이하다. 만약 데이터셋이 2개로 이원화되어 있다면, 데이터 로드 후, 관계 설정을 하는 등의 전처리가 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Pbkj62V.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;대시보드에 포함되는 요소는 크게 총 4개로 나뉘어지며, 부수적인 텍스트 박스를 위한 시트는 우선 제외했다.
구성은 아래와 같다. 아래의 순서대로 제작해보자.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;서울시 구획 지도&lt;/li&gt;
  &lt;li&gt;상세 지도&lt;/li&gt;
  &lt;li&gt;이디야 매장 수와 스타벅스와의 관계를 나타내는 테이블&lt;/li&gt;
  &lt;li&gt;기타 텍스트카드&lt;/li&gt;
  &lt;li&gt;대시보드와 동작 연결&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;서울시-구획-지도-만들기&quot;&gt;서울시 구획 지도 만들기&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/9ob0x31.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서울시 구 이름을 활용하여 맵을 형성했고, 매개변수로 조정된 스타벅스와 이디야간의 평균 거리를 구별, 색상별로 표현했다. 마지막으로 해당 거리 내 이디야 매장 수를 레이블로 표현했다.&lt;/p&gt;

&lt;h4 id=&quot;a-지도-맵핑&quot;&gt;A. 지도 맵핑&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;데이터셋에 포함된 구 컬럼을 지리적 역할 &amp;gt; 시군구로 변경해준 후, 더블클릭하면 열, 행 란에 생성된 위경도가 배치되며 지도가 표시된다.
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://i.imgur.com/FGPcNQ2.png&quot; alt=&quot;400&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;‘마크 &amp;gt; 맵’ 을 통해 구획을 영역으로 표시하자.
    &lt;ol&gt;
      &lt;li&gt;태블로에 내장된 서울시 지역구 정보로인해 자동으로 맵핑이되지만, 강서구, 중구와 같이 대한민국 내 중복되는 구 이름의 경우 오류가 발생한다.&lt;/li&gt;
      &lt;li&gt;지도 우하단 ‘2개의 알수없는 항목 &amp;gt; 위치편집’을 클릭하여 위치 편집 모달을 연다.&lt;/li&gt;
      &lt;li&gt;‘주,시,도’ 드롭다운을 눌러 위치를 서울특별시로 고정하여 에러를 해결한다.
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://i.imgur.com/oFqSE12.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;b-거리-매개변수-생성하기&quot;&gt;B. 거리 매개변수 생성하기&lt;/h4&gt;
&lt;p&gt;앞서 설명했듯, 현재 데이터셋에는 스타벅스의 데이터와 이디야의 데이터가 횡으로 연결된 형태를 띄고있다. 따라서 각각의 위경도가 따로 주어져있는 상황이다. 
태블로 맵에서 각 레코드의 위치를 표기하거나 추가적인 계산을 진행하기 위해서는 위경도를 활용하여 정확한 위치를 정해주어야한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;계산된 필드 만들기로 위치 데이터 성성
    &lt;ol&gt;
      &lt;li&gt;MAKE POINT 함수를 활용한다.&lt;/li&gt;
      &lt;li&gt;스타벅스와 이디야의 각각의 위경도 컬럼명을 대입하여 위치를 생성하자. 각 명칭은 E Location, S Location으로 지정한다.
        &lt;ul&gt;
          &lt;li&gt;E Location : ‘계산된 필드 만들기 &amp;gt; &lt;code&gt;MAKEPOINT([E Lat],[E Lng])&lt;/code&gt;’&lt;/li&gt;
          &lt;li&gt;S Location : ‘계산된 필드 만들기 &amp;gt; &lt;code&gt;MAKEPOINT([S Lat],[S Lng])&lt;/code&gt;’&lt;img src=&quot;https://i.imgur.com/GQ7GoTO.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;계산된 필드 만들기로 거리 계산
    &lt;ol&gt;
      &lt;li&gt;거리를 계산하는 수식을 생성한다. DISTANCE 함수를 활용한다. 위치간 거리를 미터 단위로 계산하자.
        &lt;ul&gt;
          &lt;li&gt;&lt;code&gt;DISTANCE([E Location],[S Location],'m')&lt;/code&gt;&lt;img src=&quot;https://i.imgur.com/V0JEfef.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;매개변수 생성 및 계산된 항목과 연동하기
    &lt;ol&gt;
      &lt;li&gt;거리를 유동적으로 선언할 수 있도록 매개변수를 생성하자.
        &lt;ol&gt;
          &lt;li&gt;‘좌측 패널에서 우클릭 &amp;gt; 매개변수 만들기’&lt;/li&gt;
          &lt;li&gt;이름은 Distance_parameters, 데이터 유형은 실수, 허용 가능한 값은 범위로 적용한다.&lt;/li&gt;
          &lt;li&gt;최소값, 최대값을 클릭하여 활성화하고, 각각 100,2000,100을 입력한 후 저장한다.&lt;img src=&quot;https://i.imgur.com/E6Ml0Xc.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;매개변수와 연동하여 True, False Boolean 값을 전달하는 계산 항목을 생성하자.
        &lt;ol&gt;
          &lt;li&gt;이름은 Distance_switch로 설정한다.&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;Distance_parameters &amp;gt; Distance&lt;/code&gt;&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;방금 생성한 계산된 항목을 이용한 계산된 항목을 생성한다.
        &lt;ol&gt;
          &lt;li&gt;공간 함수는 True False Boolean 형식의 논리연산자 구조를 활용하지 못하기 때문에 2개의 계산된 필드를 활용했다.&lt;/li&gt;
          &lt;li&gt;이름은 E_counter로 설정한다.&lt;/li&gt;
          &lt;li&gt;수식은 다음과 같다. &lt;code&gt;if [Distance_switch] == True then [E Name] end&lt;/code&gt;&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;c-맵에-시각화하기&quot;&gt;C. 맵에 시각화하기&lt;/h4&gt;
&lt;p&gt;일련의 전처리 작업이 완료되었다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;매개변수 거리값 설정에 따라 이디야 매장수를 표현하는 맵을 생성하자.
    &lt;ol&gt;
      &lt;li&gt;E_counter를 마크 &amp;gt; 레이블에 드롭한 후, 측정값 &amp;gt; 카운트 (고유)로 설정한다. 이 작업을 통해 구마다 &lt;code&gt;Distance_among&lt;/code&gt; 매개변수 값보다 가까운 거리 내의 이디야 매장 갯수가 지도에 반영된다.&lt;/li&gt;
      &lt;li&gt;마크 내 레이블로 설정된 항목을 cmd를 누른 상태로 색상으로 드롭하자.  &lt;img src=&quot;https://i.imgur.com/ItonaWD.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;이디야-매장-수와-스타벅스와의-관계를-나타내는-테이블-만들기&quot;&gt;이디야 매장 수와 스타벅스와의 관계를 나타내는 테이블 만들기&lt;/h3&gt;
&lt;p&gt;구 이름을 컬럼값으로, 구별 이디야 매장 수와, 역시 매개변수의 거리값에 연동된 이디야 매장수, 그리고 두 수의 비율을 행으로 갖는 차트를 생성해보자. 이전 시트에서 생성한 매개변수를 보이도록 설정한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;구별 이디야 매장 갯수 행
    &lt;ol&gt;
      &lt;li&gt;E Name 차원 데이터를 메트릭 데이터로 cmd + 드래그앤 드롭하여 복사한다.&lt;/li&gt;
      &lt;li&gt;각 매장의 이름이 (카운트(고유))로 성질이 변화된다. 마크 &amp;gt; 텍스트로 드롭한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;거리에 따른 이디야 매장 갯수 행
    &lt;ol&gt;
      &lt;li&gt;이전 시트에서 생성했던, E_counter 역시 메트릭 데이터로 복사한다.&lt;/li&gt;
      &lt;li&gt;역시 텍스트로 드롭하여 추가한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;비율 행
    &lt;ol&gt;
      &lt;li&gt;거리에 따른 이디야 매장 갯수를 구별 이디야 매장 수로 나누어, 스타벅스와 가까운 매장이 얼마나 분포했는지 확인하자.&lt;/li&gt;
      &lt;li&gt;계산된 필드 만들기를 열어 1,2번의 데이터를 나누어준다.&lt;img src=&quot;https://i.imgur.com/qEPsrKA.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;생성된 데이터를 마크 &amp;gt; 텍스트에 드롭한다.&lt;/li&gt;
      &lt;li&gt;우클릭하여 서식 &amp;gt; 숫자 &amp;gt; 백분율, 소수점 0 으로 설정한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;표 행열 전환하여 형태를 완성한다.
    &lt;ol&gt;
      &lt;li&gt;아래와 같다.&lt;img src=&quot;https://i.imgur.com/F6UKMAD.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;상세-지도-만들기&quot;&gt;상세 지도 만들기&lt;/h3&gt;

&lt;p&gt;1번에서 완성한 구별 구획지도와 연동되어 더욱 상세한 정보를 전달하는 역할을 담당할 예정이다. 
3번 지도에는 1번 지도에서 선택한 구의 상세 지도가 확대되어 보이게 된다. 해당 구의 스타벅스 매장이 매개변수에서 설정한 거리를 반영하여 영역으로 표시된다. 그리고 그 반경 내에 이디야의 각 매장별 레코드가 포함되어 있는 모양새이다. 
움직임은 모든 시트를 제작한 후, 대시보드 &amp;gt; 동작 기능을 통해 제작할 예정이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;스타벅스 영역과 영역 내 이디야 매장 수
    &lt;ol&gt;
      &lt;li&gt;스타벅스의 구 데이터를 더블클릭하여 위경도를 열과 행에 드롭하자.
        &lt;ol&gt;
          &lt;li&gt;만약 위경도가 생성되지 않는다면, 해당 데이터를 우클릭하여 지리적역할로 변경해주어야 한다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;매개변수의 거리값을 지도상에서 영역으로 표시하기 위해, 계산된 필드를 생성한다.
        &lt;ol&gt;
          &lt;li&gt;BUFFER 내장함수를 활용하여 영역을 생성할 수 있고, 위치는 MAKEPOINT 내장함수를 이용한다.&lt;/li&gt;
          &lt;li&gt;cal_buffer : &lt;code&gt;BUFFER(MAKEPOINT([S Lat],[S Lng]),[Distance_among],'m')&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;생성된 데이터를 마크 &amp;gt; 세부정보로 드롭한다. 이제 매개변수를 조정할 때마다 그 거리를 반영한 영역이 지도상에 표시된다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;1장에서 생성했던 E_counter 데이터를 마크 &amp;gt; 레이블로 드롭하여 영역 내 이디야 매장 갯수를 텍스트로 표시하자.
        &lt;ol&gt;
          &lt;li&gt;그 다음, 우클릭 &amp;gt; 측정값 &amp;gt; 카운트 (고유)로 설정값을 변경한다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;S Name을 세부정보로 추가해준다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;이디야 전체 매장 표기
    &lt;ol&gt;
      &lt;li&gt;이전에 생성한 E_Location 데이터를 맵으로 드래그하면 마크 &amp;gt; 계층 생성이 롤오버된다.&lt;/li&gt;
      &lt;li&gt;색상을 주황색으로 변경하여 가시적인 효과를 얻자.&lt;img src=&quot;https://i.imgur.com/EKhsJKm.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;텍스트-카드-만들기&quot;&gt;텍스트 카드 만들기&lt;/h3&gt;
&lt;p&gt;생성된 3개의 시트를 대시보드에 배치할 예정이다. 이 대시보드에 강조하고 싶은 정보가 있을때, 텍스트카드를 포함하기도 한다. 이번 대시보드에서는 현재 설정된 매개변수 거리값과, 그 기준에 맞는 서울 내 모든 이디야 매장의 수를 텍스트카드로 제작한다.&lt;/p&gt;

&lt;h4 id=&quot;a-매개변수-거리값-텍스트카드&quot;&gt;A. 매개변수 거리값 텍스트카드&lt;/h4&gt;
&lt;p&gt;앞서 생성한 매개변수를 가시적으로 확인할 수 있도록 표현한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;측정값 혹은 아무 데이터를 마크 &amp;gt; 세부정보로 드롭한다.&lt;/li&gt;
  &lt;li&gt;매개변수 Distance_among을 마크 &amp;gt; 텍스트로 드롭한다.&lt;/li&gt;
  &lt;li&gt;1번에서 드롭한 항목을 필드 밖으로 드롭하여 삭제한다.
    &lt;ol&gt;
      &lt;li&gt;모종의 이유로 매개변수는 단독으로 마크에 표시되지 않는다. 따라서 위의 불필요한 절차를 밟았다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;텍스트의 서식 탭을 열어 크기를 조정하고, 소수점 자리수를 없애준다,&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;b-매개변수-값으로-필터된-서울-내-이디야-매장-수-텍스트카드&quot;&gt;B. 매개변수 값으로 필터된 서울 내 이디야 매장 수 텍스트카드&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;앞서 생성한 E_counter를 마크 &amp;gt; 텍스트로 드롭한다.&lt;/li&gt;
  &lt;li&gt;서식 탭을 열어 크기와 소수점 자리수를 조정한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;대시보드-만들기&quot;&gt;대시보드 만들기&lt;/h3&gt;

&lt;h4 id=&quot;a-시트-배치&quot;&gt;A. 시트 배치&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;대시보드를 생성한 후, 크기 &amp;gt; 범위 &amp;gt; 자동으로 전체 화면을 사용한다.&lt;/li&gt;
  &lt;li&gt;지도 1,3을 좌우로 배치하고, 시트2를 상단에 배치한다.&lt;/li&gt;
  &lt;li&gt;최상단 좌우에 시트4,5 텍스트 카드와 매개변수를 배치한다.&lt;/li&gt;
  &lt;li&gt;모든 시트는 우클릭 &amp;gt; 제목 숨기기와 대시보드 상단 &amp;gt; 전체보기로 뷰를 설정한다.&lt;/li&gt;
  &lt;li&gt;텍스트 카드는 서식 &amp;gt; 가운데정렬, 색상 &amp;gt; 패널 색상 설정 등으로 꾸며준다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;b-동작&quot;&gt;B. 동작&lt;/h4&gt;
&lt;p&gt;시트 1과 시트2를 연결하는 동작을 생성한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;상단 메뉴 워크시트 &amp;gt; 동작을 눌러 패널을 띄운다.&lt;/li&gt;
  &lt;li&gt;동작추가 &amp;gt; 필터를 선택한다.&lt;/li&gt;
  &lt;li&gt;원본시트 &amp;gt; 시트 1, 동작 실행조건 &amp;gt; 선택, 대상시트 &amp;gt; 시트 3&lt;/li&gt;
  &lt;li&gt;필터 &amp;gt; 선택한 필드를 활성화한다. 시트 3의 2개의 계층을 모두 컨트롤하기 위해 아래와 같은 설정이 필요하다.
    &lt;ol&gt;
      &lt;li&gt;원본 필드는 E Gu, 대상 필드는 E Gu&lt;/li&gt;
      &lt;li&gt;원본 필드는 E Gu, 대상 필드는 S Gu&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;설정값을 완료했으면 확인을 눌러 저장한다.&lt;/li&gt;
  &lt;li&gt;시트 3의 좌상단 메뉴에 마우스오버하여 맵고정을 해제한다.&lt;img src=&quot;https://i.imgur.com/dAK30w9.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;결과적으로-스타벅스-주변에는-이디야가-있다&quot;&gt;결과적으로 스타벅스 주변에는 이디야가 있다.&lt;/h3&gt;
&lt;p&gt;요식업계에서 상권분석에 사용되는 척도를 대입해보자. 점포의 500m 이내를 1차 상권, 1km 이내를 2차 상권이라고 보는 업계 도메인 지식을 지표로 사용하면,&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;서울시 전체 스타벅스의 1차 상권 범위에 약 65%, 2차상권 범위에 약 90%의 이디야 매장이 포진해 있다.&lt;/li&gt;
  &lt;li&gt;도심권 상권구역인 종로,중구,용산구의 경우, 1차 상권 범위에 약 91%의 이디야 매장이 포진해 있다.&lt;/li&gt;
  &lt;li&gt;동남권 상권구역인 강남,서초,송파의 경우, 1창 상권 범위에 약 83%의 이디야 매장이 포진해 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;주요 상권의 경우 유의미한 증거를 확보할 수 있다.&lt;/p&gt;

&lt;p&gt;스타벅스가 1997년 1호점을 시작으로 2004년에 100호점을 달성한 점, 이디야의 개업일이 2002년인 점. 그리고 1차 상권이 매장의 매출에 주요한 요인이 되는 점을 고려했을때, 이디야가 낙수효과를 보기 위해 스타벅스의 주변에 자리잡는 전략을 구사했음을 합리적으로 추론해볼 수 있다.&lt;/p&gt;

&lt;p&gt;다른 커피브랜드의 비교대상이 없기 때문에 섣부른 결론을 내릴 자료는 아니지만, 추가자료를 포함하여 검증해볼만한 여지가 있음이 확실해 보인다.&lt;/p&gt;
</description>
        <pubDate>Mon, 20 Mar 2023 15:00:00 +0900</pubDate>
        <link>http://localhost:4000/articles/2023/03/20/Tableau-%EC%8A%A4%ED%83%80%EB%B2%85%EC%8A%A4%EC%99%80-%EC%9D%B4%EB%94%94%EC%95%BC-%EA%B0%84-%EC%83%81%EA%B4%80%EA%B4%80%EA%B3%84</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2023/03/20/Tableau-%EC%8A%A4%ED%83%80%EB%B2%85%EC%8A%A4%EC%99%80-%EC%9D%B4%EB%94%94%EC%95%BC-%EA%B0%84-%EC%83%81%EA%B4%80%EA%B4%80%EA%B3%84</guid>
        
        <category>태블로</category>
        
        <category>시각화</category>
        
        
        <category>시각화</category>
        
      </item>
    
      <item>
        <title>이항 분포 문제를 풀어보자</title>
        <description>&lt;h3 id=&quot;더닝크루거-vs-우공이산&quot;&gt;더닝크루거 vs 우공이산&lt;/h3&gt;
&lt;p&gt;매일 12시간씩 통계, 머신러닝을 공부하기에 실력이 일취월장하는 느낌이 든다.&lt;/p&gt;

&lt;p&gt;하지만 정작 새로운 문제에 직면했을때 느껴지는 막막함은 내 진짜 실력의 현 주소를 일깨워준다.
아마 삼키는데 급급한 탓에, 소화 덜 된 지식들이 여기저기 흩어져 있기 때문일 것이다.&lt;/p&gt;

&lt;p&gt;이 점들을 연결하고 목차가 머릿속에 들어올때, 비로소 퍼포먼스가 나올 것이 분명하다. 
아마도 다양한 문제풀이와 오답노트 복습이 점들을 연결하는 가장 빠른 지름길일 것이다.&lt;/p&gt;

&lt;h3 id=&quot;이항분포-문제풀이&quot;&gt;이항분포 문제풀이&lt;/h3&gt;
&lt;p&gt;이러한 생각의 일환으로 해커랭크라는 사이트를 찾아냈다. &lt;br /&gt;
아래와 같은 통계 문항을 하드코딩으로 풀어 제출하면 점수가 나오는 식.
아래의 문제는 이항분포를 활용한 확률 계산 문제이다.&lt;/p&gt;

&lt;p&gt;A blindfolded marksman finds that on the average he hits the target 4 times out of 5.&lt;br /&gt;
 If he fires 4 shots, what is the probability of&lt;/p&gt;

&lt;p&gt;(a) more than 2 hits?
(b) at least 3 misses?&lt;/p&gt;

&lt;p&gt;대충 명사수의 성공확률이 주어졌고, $4$발을 쐈을때의 결과를 확률로 알아보자는 문제이다.&lt;/p&gt;

&lt;p&gt;총을 쏘는 행위 자체는 각각 독립일 테니, 베르누이 시행 결과의 합이 될 것이다. &lt;br /&gt;
이항확률변수의 분포를 나타내는 질량함수는 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;P(X=x) = {_n}C{_x}p^{x}(1-p)^{n-x}&lt;/script&gt;
&lt;script type=&quot;math/tex&quot;&gt;=\dfrac{n!}{x!(n-x)!} p^{x}(1-p)^{n-x}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;계산에는 조합이 포함되기에, 팩토리얼 함수를 재귀함수로 선언했다.&lt;/p&gt;

&lt;p&gt;사수는 4/5 즉 0.8의 성공확률을 갖는다. &lt;br /&gt;
1번 문항의 경우 2발 보다 많이 맞출 확률을, 2번 문항의 경우 최소 3발이 불발할 확률을 구하는 문제이다.&lt;/p&gt;

&lt;p&gt;따라서 답은 아래와 같이 도출된다.&lt;br /&gt;
2발 이상 맞출 확률은 0발만 맞출 확률, 1발만 맞출 확률, 2발만 맞출 확률의 합을 전체 확률에서 뺀 값이다. ⇒ 0.819 &lt;br /&gt;
최소 3발이 불발할 확률은 0발만 맞출 확률, 1발만 맞출 확률의 합이다. ⇒ 0.027&lt;/p&gt;

&lt;!--more--&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import sys

def factorial(n):
    if n &amp;gt; 0:
        return n * factorial(n-1)
    else:
        return 1


def get_binominal(n,p,rounder):
    cal = 0
    for x in range(rounder):

        cal += (factorial(n)/(factorial(x) * factorial(n - x))) * (p**x) * ((1 - p) ** (n - x))
    return cal


more_than_2hit = 1-get_binominal(4,0.8,3)
at_least_3miss = get_binominal(4,0.8,2)

print(&quot;{:.3f}&quot;.format(more_than_2hit,file=sys.stdout))
print(&quot;{:.3f}&quot;.format(at_least_3miss,file=sys.stdout))

&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 11 Feb 2023 15:00:00 +0900</pubDate>
        <link>http://localhost:4000/articles/2023/02/11/%EC%9D%B4%ED%95%AD%EB%B6%84%ED%8F%AC-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2023/02/11/%EC%9D%B4%ED%95%AD%EB%B6%84%ED%8F%AC-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4</guid>
        
        <category>이항분포</category>
        
        <category>통계</category>
        
        
        <category>statistics</category>
        
      </item>
    
      <item>
        <title>모델 평가하는 방법</title>
        <description>&lt;h3 id=&quot;이진분류&quot;&gt;이진분류&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Br7Hc8g.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/qft6Hs1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;정확도 Accuracy (전체 데이터 중 맞게 예측한 것의 비율)
    &lt;ul&gt;
      &lt;li&gt;$\dfrac{TP + TN}{TP + TN + FP + FN}$&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://i.imgur.com/HC7uFwU.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정밀도 Precision (양성이라 예측한 것 중에서 실제 양성의 비율)
    &lt;ul&gt;
      &lt;li&gt;$\dfrac{TP}{TP + FP}$&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://i.imgur.com/rceWq5b.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Recall (TPR)(참인 데이터들 중에서 참이라고 예측한것)
    &lt;ul&gt;
      &lt;li&gt;$\dfrac{TP}{TP+FN}$&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://i.imgur.com/3N0aELf.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Fall Out (FPR False Position Ratio) (실제 양성이 아닌데 양성이라 잘못 에측한 경우)
    &lt;ul&gt;
      &lt;li&gt;$\dfrac{FP}{FP + TN}$&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://i.imgur.com/75lQTC1.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;F1 Score (Recall과 Precision을 결합한 지표)
    &lt;ul&gt;
      &lt;li&gt;F-score에서 $\beta$ 를 1로 둔다.
        &lt;ul&gt;
          &lt;li&gt;$F_\beta = (1+\beta)(precision \times recall)$&lt;/li&gt;
          &lt;li&gt;$\therefore F_1 = (2)(precision \times recall)$&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ROC  곡선
    &lt;ul&gt;
      &lt;li&gt;FPR이 x축, TPR이 y축으로, FPR이 변할때 TPR의 변화를 그림
        &lt;ul&gt;
          &lt;li&gt;FPR : recall, FPR : fall-out&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;직선에 가까울수록 머신러닝 모델의 성능이 떨어지는것으로 판단한다.
        &lt;ul&gt;
          &lt;li&gt;완벽한 분류 시
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://i.imgur.com/Yfy1ddz.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;적당히 잘 분류 시
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://i.imgur.com/O8ypt0S.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;분류 성능이 나쁠 시
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://i.imgur.com/5t2qMGq.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;AUC
    &lt;ul&gt;
      &lt;li&gt;ROC 곡선 아래의 면적이다.&lt;/li&gt;
      &lt;li&gt;일반적으로 1에 가까울 수록 좋은 수치를 가진다.&lt;/li&gt;
      &lt;li&gt;기울기가 1인 직선 아래의 면적이 0.5 ⇒ AUC는 0.5보다 커야한다.
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://i.imgur.com/G959pnW.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;wine-분류기-roc-커브&quot;&gt;wine 분류기 ROC 커브&lt;/h4&gt;

&lt;!--more--&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score

red_url = 'https://raw.githubusercontent.com/PinkWink/ML_tutorial/master/dataset/winequality-red.csv'
white_url = 'https://raw.githubusercontent.com/PinkWink/ML_tutorial/master/dataset/winequality-white.csv'
red_wine = pd.read_csv(red_url,sep=';')
white_wine = pd.read_csv(white_url,sep=';')

wine = pd.concat([red_wine,white_wine])
wine['taste'] = [1. if grade &amp;gt; 5 else 0. for grade in wine.quality]

X = wine.drop(['quality','taste'],axis=1)
y = wine['taste']

X_train, X_test, y_train, y_test = train_test_split(X,y,test_size = 0.2, random_state=13)

wine_tree = DecisionTreeClassifier(max_depth = 2, random_state = 13)
wine_tree.fit(X_train,y_train)
y_pred_tr = wine_tree.predict(X_train)
y_pred_test = wine_tree.predict(X_test)

print('Train Acc : ',accuracy_score(y_train,y_pred_tr))
print('Train Acc : ',accuracy_score(y_test,y_pred_test))

from sklearn.metrics import (accuracy_score, precision_score, recall_score, f1_score, roc_auc_score, roc_curve)

print('Acurracy: ', accuracy_score(y_test, y_pred_test))
print('Recall: ', recall_score(y_test, y_pred_test))
print('Precision: ', precision_score(y_test, y_pred_test))
print('AUC score: ', roc_auc_score(y_test, y_pred_test))
print('F1 Score: ', f1_score(y_test, y_pred_test))

import matplotlib.pyplot as plt

pred_proba = wine_tree.predict_proba(X_test)[:,1]
fpr, tpr, thresholds = roc_curve(y_test, pred_proba)

plt.figure(figsize=(10,8))
plt.plot([0,1],[0,1])
plt.plot(fpr,tpr)
plt.grid()
plt.show()
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 10 Feb 2023 15:00:00 +0900</pubDate>
        <link>http://localhost:4000/articles/2023/02/10/%EB%AA%A8%EB%8D%B8-%ED%8F%89%EA%B0%80-%EB%B3%B5%EC%82%AC%EB%B3%B8-2</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2023/02/10/%EB%AA%A8%EB%8D%B8-%ED%8F%89%EA%B0%80-%EB%B3%B5%EC%82%AC%EB%B3%B8-2</guid>
        
        <category>모델평가</category>
        
        <category>머신러닝</category>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>기초통계 - 연속형확률분포</title>
        <description>&lt;h2 id=&quot;연속형-확률분포&quot;&gt;연속형 확률분포&lt;/h2&gt;

&lt;h3 id=&quot;분포간-관계도&quot;&gt;분포간 관계도&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/S851Wmd.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;함수&quot;&gt;함수&lt;/h3&gt;
&lt;h4 id=&quot;a-확률-밀도-함수pdf&quot;&gt;A. 확률 밀도 함수(pdf)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;확률밀도함수 : 연속형 확률 변수 x에 대해 함수 f(x) 가 아래의 조건을 만족하면 확률밀도함수라고 함.
    &lt;ol&gt;
      &lt;li&gt;모든 X에 대해서 $f(x) \geq 0$&lt;/li&gt;
      &lt;li&gt;$P(x \in (-\infty, \infty)) = \int_{-\infty}^{\infty}f(x)dx = 1$&lt;/li&gt;
      &lt;li&gt;$P(a \leq X \leq b) = \int_{a}^{b}f(x)dx$&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;확률 밀도 함수의 성질 (선은 면적이 없기 때문에 0. )
    &lt;ol&gt;
      &lt;li&gt;$P(X = a) = P(a \leq X \leq a) = \int_{a}^{a}dx = 0$&lt;/li&gt;
      &lt;li&gt;$P(a \leq X \leq b) = P(a \leq X &amp;lt; b) = P(a &amp;lt; X \leq b) = P(a &amp;lt; X &amp;lt; b)$&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;확률 밀도함수의 평균과 분산
    &lt;ol&gt;
      &lt;li&gt;$E(X) = \int_{-\infty}^{\infty}xf(x)dx$&lt;/li&gt;
      &lt;li&gt;$Var(x) = E(X - \mu)^2$
        &lt;ol&gt;
          &lt;li&gt;$= \int_{-\infty}^{\infty}(x - \mu)^2f(x)dx$&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;b-누적분포함수cdf&quot;&gt;B. 누적분포함수(cdf)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;누적분포함수 : 확류밀도함수를 적분하면 누적분포함수가 된다.
    &lt;ol&gt;
      &lt;li&gt;$F(x) = P[X \leq x] = \int_{-\infty}^{x}f(x)dx$&lt;/li&gt;
      &lt;li&gt;$\dfrac{d}{dx}F(x) = f(x)$ 누적분포함수를 미분하면 pdf가 됨&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;누적분포함수의 성질
    &lt;ol&gt;
      &lt;li&gt;$0 \leq F(x) \leq 1$&lt;/li&gt;
      &lt;li&gt;만약 $b \geq a, F(b) \geq F(a)$&lt;/li&gt;
      &lt;li&gt;$F(b) - F(a) = P[a \leq X \leq b]$ 
&lt;img src=&quot;https://i.imgur.com/0MkToik.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;분포&quot;&gt;분포&lt;/h3&gt;
&lt;h4 id=&quot;a-균일-분포&quot;&gt;A. 균일 분포&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;정의
    &lt;ul&gt;
      &lt;li&gt;uniform distribution : 확률 변수 X가 a와 b사이에서 아래와 같은 확률 밀도 함수 (pdf)를 가짐&lt;img src=&quot;https://i.imgur.com/RNRolpx.png&quot; alt=&quot;250&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;pdf : $f(x) = \begin{cases}\dfrac{1}{b-a}, a \leq x \leq b \ 0, otherwise  \end{cases}$&lt;/li&gt;
      &lt;li&gt;cdf : $f(x) = \begin{cases} 0,  x \leq a \ \dfrac{1}{b-a}, a \leq x \leq b \ 1, x\geq b \end{cases}$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;평균과 분산
    &lt;ul&gt;
      &lt;li&gt;평균 (기댓값)$E[X] = \dfrac{b+a}{2} ⇒ E[X] = \int_{a}^{b}xf(x)dx = \int_{a}^{b}x\dfrac{1}{b-a}dx = \left[\dfrac{1}{b-a}\dfrac{1}{2} x^2\right]_{a}^{b} = \dfrac{b^2 - a^2}{2(b-a)}= \dfrac{b+a}{2}$
        &lt;ul&gt;
          &lt;li&gt;$\therefore \dfrac{b+a}{2}$&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;$E[X^2] = \int_{a}^{b}x^2\dfrac{1}{b-a} = \left[\dfrac{1}{b-a}\dfrac{1}{3}x^3\right]_{a}^{b} = \dfrac{b^3-a^3}{3(b-a)} = \dfrac{(b-a)(b^2+ab+a^2)}{3(b-a)}=\dfrac{(b^2+ab+a^2)}{3}$
        &lt;ul&gt;
          &lt;li&gt;$\therefore\dfrac{(b^2+ab+a^2)}{3}$&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;분산 $var[X] = E[X^2] - (E[X])^2 = \dfrac{b^2+ab+a^2}{3} - (\dfrac{b+a}{2})^2 = \dfrac{(b^2+ab+a^2)}{3}-\dfrac{(b^2+2ab+a^2)}{4} = \dfrac{4b^2+4ab+4a^2-3b^2-6ab-3a^2}{12} = \dfrac{b^2-2ab+a^2}{12}$
        &lt;ul&gt;
          &lt;li&gt;$\therefore \dfrac{(b-a)^2}{12}$&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;b-정규분포&quot;&gt;B. 정규분포&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;정의
    &lt;ul&gt;
      &lt;li&gt;가우스 분포라고도 불림.&lt;/li&gt;
      &lt;li&gt;$X \sim N(\mu,\sigma^2)$&lt;img src=&quot;https://i.imgur.com/zC7XmD0.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;2개의 표준편차 $(\mu \pm 2\sigma)$ 안에는 95/44%의 확률변수값들이 있어야 함.&lt;/li&gt;
      &lt;li&gt;좌유 3개의 표준편차 $(\mu \pm 3\sigma)$ 안에는 99.74%에 이르는 대부분의 값들이 반드시 있어야 함.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;확률 밀도 함수
    &lt;ul&gt;
      &lt;li&gt;확률 밀도 함수&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
f(x) = \dfrac{1}{\sqrt{2\pi\sigma^2}}e^{-\dfrac{1}{2}\left[\dfrac{x-\mu}{\sigma}\right]^2}, -\infty &lt; x &lt; \infty, -\infty &lt; \mu &lt; \infty, \sigma^2 &gt; 0 %]]&gt;&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;평균 &lt;script type=&quot;math/tex&quot;&gt;E[x] = \mu&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;분산
        &lt;ul&gt;
          &lt;li&gt;$var[X] = \sigma^2$&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;평균과 분산 유도 reference
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://angeloyeo.github.io/2020/09/14/normal_distribution_derivation.html&quot;&gt;정규분포의 공식 유도 - 공돌이의 수학정리노트&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;c-표준-정규분포&quot;&gt;C. 표준 정규분포&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;정의
    &lt;ul&gt;
      &lt;li&gt;확률변수 X를 표준화한 확률변수 Z의 분포&lt;/li&gt;
      &lt;li&gt;정규분포를 따르는 확률변수 $X \sim N(\mu,\sigma^2)$ . 확률변수 $X$를 $Z(=\dfrac{X-\mu}{\sigma})$ 로 치환하면 확률변수 Z의 분포는 표준정규분포가 됨.&lt;/li&gt;
      &lt;li&gt;평균이 0, 분산은 1의 값을 가짐.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;확률밀도함수
    &lt;ul&gt;
      &lt;li&gt;$f(z) = \dfrac{1}{\sqrt{2\pi}}e^{-\dfrac{1}{2}(z)^2}, (-\infty &amp;lt; z &amp;lt; +\infty)$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정규 분포의 성질
    &lt;ul&gt;
      &lt;li&gt;$X \sim N(\mu, \sigma^2)$ 일때, 임의의 상수 a,b에 대해 $aX+b \sim N(a\mu + b, a^2\sigma^2)$&lt;/li&gt;
      &lt;li&gt;$X \sim N(\mu, \sigma^2)$ 일때, $z = \dfrac{X-\mu}{\sigma}, z\sim N(0,1)$&lt;/li&gt;
      &lt;li&gt;$X \sim N(\mu, \sigma_{1}^{2)},Y \sim N(\mu, \sigma_{2}^{2)}$ 이고 X,Y가 독립일때 $aX + bY \sim N(a\mu_{1} + b\mu_{2}, a^{2}\sigma_{1}^{2} + b^{2} \sigma_{2}^{2} + 2\sigma_{1,2})$
        &lt;ul&gt;
          &lt;li&gt;X,Y가 독립일시, 공분산은 0&lt;/li&gt;
          &lt;li&gt;$\therefore aX + bY \sim N(a\mu_{1} + b\mu_{2}, a^{2}\sigma_{1}^{2} + b^{2} \sigma_{2}^{2})$&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;신뢰구간 z값
        &lt;ul&gt;
          &lt;li&gt;$0.95 : 1.96$&lt;/li&gt;
          &lt;li&gt;$0.99 : 2.58$&lt;/li&gt;
          &lt;li&gt;$0.999 : 3.29$&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이항분포의 정규 근사
    &lt;ul&gt;
      &lt;li&gt;$X\sim B(n,p)$ 일때, 확률 변수 X는 n이 충분히 크면 근사적으로 정규 분포 $X \sim N(np,np(1-p))$를 따른다.&lt;/li&gt;
      &lt;li&gt;$Z = \dfrac{X-np}{\sqrt{(np(1-p))}} \sim N(0,1)$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예시
    &lt;ol&gt;
      &lt;li&gt;평균키 $175cm$ 분산이 $25cm^2$ 인 정규분포에서 170cm ~ 180cm 의 구간확률은?
        &lt;ol&gt;
          &lt;li&gt;평균 = 0, 표준편차 = 1&lt;/li&gt;
          &lt;li&gt;$-1 \leq Z \leq 1$&lt;/li&gt;
          &lt;li&gt;0.6826&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;아침식사로 먹는 빵의 열량 $X\sim N(200,12^2)$ 우유의 열량 $Y\sim N(85,9^2)$ 이며 서로 독립이다. 아침에 300cal 이상 섭취할 확률은?
        &lt;ol&gt;
          &lt;li&gt;$aX + bY \sim N(a \mu_{1} + b \mu_{2}, a^{2}\sigma_{1}^{2}+ b^2\sigma_{2}^2)$  ⇒ $(285,15^2)$&lt;/li&gt;
          &lt;li&gt;$Z = \dfrac{X - \mu}{\sigma} = \dfrac{300-285}{15} = 1$ ⇒ 표준정규분포표 0.8413&lt;/li&gt;
          &lt;li&gt;$P(Z \leq 1) = 0.1587$&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;d-지수분포&quot;&gt;D. 지수분포&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;포아송 분포&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;지수분포&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;일정한 시간이나 구간에서 발생하는 특정한 사건의 수를 변수값으로 하는 확률변수의 분포&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;한 사건이 발생한 후 다음 사건이 발생할 때 까지의 시간이나 면적을 변수값으로 하는 확률변수의 분포&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;새로 구입한 자동차에서 발견되는 흠집 수&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;새로 구입한 자동차에서 1개의 흠집이 발견되고 또 다른 흠집이 발견되기까지의 면적&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1달동안 아파트 엘레베이터의 고장 건수&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;엘레베이터가 고장난 후 다시 고장날때까지 걸리는 시간&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정의
    &lt;ul&gt;
      &lt;li&gt;단위 시간, 면적, 거리에서 발생하는 사건의 횟수가 포아송 분포에 따른다면, 사건과 사건 사이의 시간을 변수값으로 하는 확률변수는 연속확률변수가 됨. 이 확률변수는 지수분포한다,&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;특징
    &lt;ol&gt;
      &lt;li&gt;확률변수 X의 값이 증가함에 따라 오른쪽꼬리가 감소하는 경사진 모양의 분포를 한다.&lt;/li&gt;
      &lt;li&gt;람다 값에 따라 모양이 달라진다&lt;/li&gt;
      &lt;li&gt;람다 값이 클수록 수직축의 절편값이 커진다.&lt;/li&gt;
      &lt;li&gt;지수분포를 하는 확률변수의 평균과 표준편차는 같다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;확률밀도함수
    &lt;ul&gt;
      &lt;li&gt;pdf
        &lt;ul&gt;
          &lt;li&gt;$f(x) = \lambda e^{-\lambda x}, (0 &amp;lt; x &amp;lt; \infty, 0&amp;lt;\lambda)$&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;cdf
        &lt;ul&gt;
          &lt;li&gt;$F(x) = 1 - e^{\lambda x}, x\geq 0$&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;용어
        &lt;ul&gt;
          &lt;li&gt;x : 한 사건이 발생한 후 다음 사건까지의 시간(길이,면적)을 변수값으로 하는 확률 변수&lt;/li&gt;
          &lt;li&gt;e : 자연 로그의 밑수&lt;/li&gt;
          &lt;li&gt;$\lambda$ : 일정한 단위 내 평균적으로 발생하는 사건의 수, 포아송분포하는 확률변수의 평균&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;평균과 분산
    &lt;ul&gt;
      &lt;li&gt;평균 : $\mu = E(X) = \dfrac{1}{\lambda}$&lt;/li&gt;
      &lt;li&gt;분산 : $\dfrac{1}{\lambda^2}$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;확률 계산
    &lt;ul&gt;
      &lt;li&gt;확률변수값이 a시간보다 작을 확률 $P(X\leq a)$
        &lt;ul&gt;
          &lt;li&gt;$P(X\leq a) = P(0 \leq X \leq a)$
            &lt;ul&gt;
              &lt;li&gt;$= \int_{0}^{a}f(x)dx = \int_{0}^{a}\lambda e^{-\lambda x}dx$&lt;/li&gt;
              &lt;li&gt;$=\left[-e^{\lambda x}\right]_{0}^{a} = (-e^{-\lambda a})-(-e^{-\lambda \cdot 0})$&lt;/li&gt;
              &lt;li&gt;$\therefore 1-e^{-\lambda a}$&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;확률변수값이 a시간보다 클 확률 $P(X\geq a)$
        &lt;ul&gt;
          &lt;li&gt;$P(X\geq a)$
            &lt;ul&gt;
              &lt;li&gt;$= \int_{0}^{a}f(x)dx = \int_{0}^{a}\lambda e^{-\lambda x}dx$&lt;/li&gt;
              &lt;li&gt;$=\left[-e^{\lambda x}\right]_{a}^{\infty} = (-e^{-\lambda \infty})-(-e^{-\lambda \cdot a})$&lt;/li&gt;
              &lt;li&gt;$\therefore e^{-\lambda a}$&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;확률변수값이 a에서 b 사이일 확률 $P(a \leq X \leq b)$
        &lt;ul&gt;
          &lt;li&gt;$P(a \leq X \leq b)$
            &lt;ul&gt;
              &lt;li&gt;$=\int_{a}^{b}f(x)dx = \int_{a}^{b}\lambda e^{-\lambda x}dx$&lt;/li&gt;
              &lt;li&gt;$\therefore(-e^{-\lambda b})-(-e^{- \lambda a})$&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예시
    &lt;ul&gt;
      &lt;li&gt;A은행에서 시간당 2명의 손님이 계좌를 개설한다. 30분 이내로 새로운 계좌가 개설될 확률은?
        &lt;ul&gt;
          &lt;li&gt;$1-e^{-\frac{1}{30}\times 30} \approx 0.63$&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;버스 정류장에 시간당 평균 6대가 정차한다. 10분에서 20분 대기할 확률은?
        &lt;ul&gt;
          &lt;li&gt;$P(10\leq X\leq 20)$&lt;/li&gt;
          &lt;li&gt;$(1-e^{-\frac{1}{10}\times 20})-\left(1-e^{-\frac{1}{10}\times 10}\right) \approx 0.233$&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;계산 참고
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://ko.wikihow.com/%EC%A7%80%EC%88%98%EA%B0%80-%EC%86%8C%EC%88%98%EC%9D%BC-%EB%95%8C-%EA%B3%84%EC%82%B0%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95&quot;&gt;지수가 소수일 때 계산하는 방법 - wikiHow&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://math100.tistory.com/36&quot;&gt;지수분포 문제풀이&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;한계
    &lt;ul&gt;
      &lt;li&gt;지수분포의 무기억성
        &lt;ul&gt;
          &lt;li&gt;어떤 시점으로 부터 소요되는 시간은 과거 시간에 영향을 받지 않음.&lt;/li&gt;
          &lt;li&gt;예로, 한달동안 사용한 전구와 새 전구의 남은 수명은 같다고 생각함.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;때문에 생존분석에서는 Weibull 분포, log-normal 분포를 사용해 예측한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;e-카이제곱분포&quot;&gt;E. 카이제곱분포&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;카이제곱분포
    &lt;ul&gt;
      &lt;li&gt;정의
        &lt;ol&gt;
          &lt;li&gt;$x_{i}(i=1,2\cdots,n)$를 정규분포하는 모집단 $N(\mu,\sigma^2)$에서 추출한 서로 독립적인 표본 관측치일 경우&lt;/li&gt;
          &lt;li&gt;이들은 각각 독립적이며 정규분포하는 확률변수가 됨.&lt;/li&gt;
          &lt;li&gt;이를 표준화한 값 $(Z_{i})$들 역시 서로 독립이며 표준정규분포하는 확률변수값들이 됨.&lt;/li&gt;
          &lt;li&gt;n개의 확률변수 $(Z_{i})$를 제곱하여 더한 변수는 카이제곱분포하는 확률변수가 됨.
            &lt;ol&gt;
              &lt;li&gt;$Z = Z_{1}^{2}+ Z = Z_{2}^{2}+ \cdots + Z = Z_{n}^2$&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;n의 갯수에 따라 카이제곱분포의 자유도가 결정됨.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;특징
        &lt;ul&gt;
          &lt;li&gt;확률변수는 연속확률변수로, 항상 양의 값만 가짐&lt;/li&gt;
          &lt;li&gt;오른쪽 꼬리를 가진 비대칭 분포&lt;/li&gt;
          &lt;li&gt;자유도$(df)$에 따라 모양이 변함&lt;/li&gt;
          &lt;li&gt;자유도$(df)$가 커질수록 정규분포에 가까워짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;용도
        &lt;ul&gt;
          &lt;li&gt;단일 모집단의 분산에 대한 추정과 검정을 할 경우 사용됨.
            &lt;ul&gt;
              &lt;li&gt;표본 분산 $S^2$을 이용해 모집단 분산$\sigma^2$을 추정할때&lt;/li&gt;
              &lt;li&gt;표본 분산 $S^2$을 이용해 모집단 분산$\sigma^2$에 대한 가설을 검정할때&lt;/li&gt;
              &lt;li&gt;변수간 독립인지&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;모집단의 분산 $\sigma^2$과 표본분산 $S^2$의 비를 나타내는 확률 변수는 자유도가 (n-1)인 카이제곱분포한다.
            &lt;ul&gt;
              &lt;li&gt;$\dfrac{(n-1)S^{2}}{\sigma^{2}}\sim x^2_{n-1}$&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;레퍼런스
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://angeloyeo.github.io/2021/12/13/chi_square.html&quot;&gt;카이제곱 분포와 검정 - 공돌이의 수학정리노트&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;f-f분포&quot;&gt;F. F분포&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;F분포
    &lt;ul&gt;
      &lt;li&gt;정의
        &lt;ul&gt;
          &lt;li&gt;서로 독립인 두 정규모집단의 분산 또는 표준편차들의 비율에 대한 통계적 추론. 혹은 분산분석에 활용된다.&lt;/li&gt;
          &lt;li&gt;나눗셈을 통해 분산이 1(같은지)인지 아닌지 확인&lt;/li&gt;
          &lt;li&gt;$Y_{1} \sim x^2(v_1),Y_{2} \sim x^2(v_2)$ 이면 $F\sim \dfrac{y1/v1}{y2/v2},F&amp;gt;0$
            &lt;ul&gt;
              &lt;li&gt;2개의 카이제곱분포하는 확률변수 값을 각각의 자유도로 나눈, 평균 카이제곱값의 비를 변수값으로 하는 확률변수의 분포.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;확률변수
        &lt;ul&gt;
          &lt;li&gt;각 카이제곱분포의 평균의 비이므로
            &lt;ul&gt;
              &lt;li&gt;$F = \dfrac{\dfrac{x^2&lt;em&gt;{(n&lt;/em&gt;{1}-1)}}{(n_{1}-1)}}{\dfrac{x^2&lt;em&gt;{(n&lt;/em&gt;{2}-1)}}{(n_{2}-1)}}$&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;정리하면 (모집단의 분산이 서로 차이가 없음을 전제로 하므로 1이됨)
            &lt;ul&gt;
              &lt;li&gt;$ \dfrac{\dfrac{S^2&lt;em&gt;1}{\sigma^2_1}}{\dfrac{S^2_2}{\sigma^2_2}} = \dfrac{\dfrac{S^2_1}{S^2_2}}{\dfrac{\sigma^2_1}{\sigma^2&lt;/em&gt;{2}}}=\dfrac{S^2_1}{S^2_2} $ //에러 체크&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;특징
        &lt;ul&gt;
          &lt;li&gt;2개의 자유도에 따라 F분포의 모양이 결정됨.&lt;/li&gt;
          &lt;li&gt;오른쪽꼬리를 갖는 비대칭 모양이나, 자유도가 증가함에 따라 정규분포 모양을 띈다.&lt;/li&gt;
          &lt;li&gt;항상 양의 값을 가진다.&lt;/li&gt;
          &lt;li&gt;카이제곱 분포와 다르게 두집단의 분산을 다룬다.&lt;/li&gt;
          &lt;li&gt;F분포의 역수를 취할 수 있다.
            &lt;ul&gt;
              &lt;li&gt;$F_{1-a}(k,m) = \dfrac{1}{F_a(m,k)}$&lt;/li&gt;
              &lt;li&gt;즉 $F_{0.95,10,20} = \dfrac{1}{F_{0.05,20,10}}$&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;예제
        &lt;ul&gt;
          &lt;li&gt;모집단 1에서 20개, 모집단 2에서 10개 추출했다.
            &lt;ul&gt;
              &lt;li&gt;$Y_{1}\sim N(\mu_{1}= 4, \sigma_1^{2}=4^2),Y_2\sim N(\mu_{2}= 12, \sigma_2^{2}=8^2)$&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;이 F분포에서 표본분산비율이 c값보다 적을 확률이 0.05. 여기서 c를 찾아라.
            &lt;ul&gt;
              &lt;li&gt;$P \left[\dfrac{S_{1}^{2}}{S_{2}^{2}}\leq c \right] = 0.05$&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;풀이
            &lt;ul&gt;
              &lt;li&gt;$F=\dfrac{S_{1}^2/\sigma_{1}^2}{S_{2}^2/\sigma_{2}^2}\sim F(19,9)$&lt;/li&gt;
              &lt;li&gt;$\dfrac{S_{1}^2\sigma_{2}^2}{S_{2}^2/\sigma_{1}^2}\leq \dfrac{a_2^2}{a_1^2}c = \dfrac{S_{1}^2\sigma_{2}^2}{S_{2}^2/\sigma_{1}^2}\leq \dfrac{8^2}{4^2}c=P[F \leq 4c] = 0.05$&lt;/li&gt;
              &lt;li&gt;$P[F&amp;gt;f_{0.95}]=0.05$&lt;/li&gt;
              &lt;li&gt;$4c=f_{0.95}(19,9)=\dfrac{1}{f_{0.05}(9,19)}=\dfrac{1}{2.42}$&lt;/li&gt;
              &lt;li&gt;c=0.103&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;g-t분포&quot;&gt;G. t분포&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;t분포
    &lt;ul&gt;
      &lt;li&gt;정의
        &lt;ul&gt;
          &lt;li&gt;정규분포와 거의 유사하나 꼬리가 더 두꺼운 분포를 띈다.&lt;/li&gt;
          &lt;li&gt;자유도가 30개 이상이면 표준정규분포(Z분포)와 거의 일치한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;특징
        &lt;ul&gt;
          &lt;li&gt;표준정규분포(Z분포)와 같이 평균이 0&lt;/li&gt;
          &lt;li&gt;자유도에 따라 분포 모양이 변함&lt;/li&gt;
          &lt;li&gt;자유도가 증가함에 따라 분산은 1에 접근함&lt;/li&gt;
          &lt;li&gt;표본의 크기가 커질수록 자유도는 증가. 30개 이상일시 Z분포와 거의 동일한 분포&lt;/li&gt;
          &lt;li&gt;$\overline{x}$의 표준화한 Z값과 거의 같다. $Z=\dfrac{\overline{x}-\mu}{\dfrac{\sigma}{\sqrt{n}}}$
            &lt;ul&gt;
              &lt;li&gt;모집단의 표준편차 대신, 표본의 표준편차를 사용한것.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;확률변수
        &lt;ul&gt;
          &lt;li&gt;$t_{(n-1)} = \dfrac{\overline{x}-\mu}{\dfrac{S}{\sqrt{n}}}$&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;예시
        &lt;ul&gt;
          &lt;li&gt;$x_{1} \cdots x_{25}$ 은 $\sim iid N(100,10^2)$일때 $P[T&amp;lt;c] \leq 0.05$ 를 구하라.
            &lt;ul&gt;
              &lt;li&gt;$T\sim t(v=24) ⇒ P[T \leq -t_{a,24}] ⇒ P[T \geq t_{a,24}]$&lt;/li&gt;
              &lt;li&gt;$a = 1.711$&lt;/li&gt;
              &lt;li&gt;$\therefore -1.711$&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 07 Jan 2023 15:00:00 +0900</pubDate>
        <link>http://localhost:4000/articles/2023/01/07/%EC%97%B0%EC%86%8D%ED%98%95%EB%B6%84%ED%8F%AC</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2023/01/07/%EC%97%B0%EC%86%8D%ED%98%95%EB%B6%84%ED%8F%AC</guid>
        
        <category>통계</category>
        
        <category>분포</category>
        
        
        <category>통계</category>
        
      </item>
    
  </channel>
</rss>
